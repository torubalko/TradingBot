#pragma once

#include <chrono>
#include <atomic>
#include <array>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <sstream>

// ???????????????????????????????????????????????????????????????????????????????
// HIGH-PRECISION LATENCY TRACKER FOR HFT (LOCK-FREE)
// ???????????????????????????????????????????????????????????????????????????????

namespace hft {

// ???????????????????????????????????????????????????????????????????????????????
// High-Resolution Timer
// ???????????????????????????????????????????????????????????????????????????????
class HighResTimer {
public:
    using Clock = std::chrono::high_resolution_clock;
    using SysClock = std::chrono::system_clock;
    
    static int64_t NowNs() {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            Clock::now().time_since_epoch()
        ).count();
    }
    
    static int64_t NowUs() {
        return std::chrono::duration_cast<std::chrono::microseconds>(
            Clock::now().time_since_epoch()
        ).count();
    }
    
    static int64_t NowMs() {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            Clock::now().time_since_epoch()
        ).count();
    }
    
    // Unix timestamp in milliseconds (for comparison with exchange timestamps)
    static int64_t UnixMs() {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            SysClock::now().time_since_epoch()
        ).count();
    }
};

// ???????????????????????????????????????????????????????????????????????????????
// Lock-Free Latency Stats (stores values in MICROSECONDS)
// ???????????????????????????????????????????????????????????????????????????????
struct AtomicLatencyStats {
    std::atomic<int64_t> count{0};
    std::atomic<int64_t> sumUs{0};
    std::atomic<int64_t> minUs{INT64_MAX};
    std::atomic<int64_t> maxUs{0};
    std::atomic<int64_t> lastUs{0};

    void RecordUs(int64_t us) {
        if (us < 0 || us > 60000000) return;  // 0..60s guard
        count.fetch_add(1, std::memory_order_relaxed);
        sumUs.fetch_add(us, std::memory_order_relaxed);
        lastUs.store(us, std::memory_order_relaxed);

        int64_t curMin = minUs.load(std::memory_order_relaxed);
        while (us < curMin && !minUs.compare_exchange_weak(curMin, us, std::memory_order_relaxed));
        int64_t curMax = maxUs.load(std::memory_order_relaxed);
        while (us > curMax && !maxUs.compare_exchange_weak(curMax, us, std::memory_order_relaxed));
    }

    void RecordNs(int64_t ns) { RecordUs(ns / 1000); }
    void RecordMs(int64_t ms) { RecordUs(ms * 1000); }

    double AvgUs() const {
        int64_t c = count.load(std::memory_order_relaxed);
        if (c == 0) return 0.0;
        return static_cast<double>(sumUs.load(std::memory_order_relaxed)) / c;
    }

    double AvgMs() const { return AvgUs() / 1000.0; }
    int64_t MinUs() const { int64_t m = minUs.load(std::memory_order_relaxed); return m == INT64_MAX ? 0 : m; }
    int64_t MaxUs() const { return maxUs.load(std::memory_order_relaxed); }
    int64_t LastUs() const { return lastUs.load(std::memory_order_relaxed); }
    int64_t Count() const { return count.load(std::memory_order_relaxed); }

    void Reset() {
        count.store(0, std::memory_order_relaxed);
        sumUs.store(0, std::memory_order_relaxed);
        minUs.store(INT64_MAX, std::memory_order_relaxed);
        maxUs.store(0, std::memory_order_relaxed);
        lastUs.store(0, std::memory_order_relaxed);
    }
};

// ???????????????????????????????????????????????????????????????????????????????
// Lock-Free Histogram (for percentiles)
// ???????????????????????????????????????????????????????????????????????????????
template<size_t NumBuckets = 500, int64_t MaxLatencyMs = 5000>
class LockFreeHistogram {
public:
    static constexpr int64_t BUCKET_SIZE_MS = MaxLatencyMs / NumBuckets;

    LockFreeHistogram() { Reset(); }

    void RecordMs(int64_t latencyMs) {
        if (latencyMs < 0 || latencyMs >= MaxLatencyMs) return;
        size_t bucket = static_cast<size_t>(latencyMs / BUCKET_SIZE_MS);
        if (bucket >= NumBuckets) bucket = NumBuckets - 1;
        buckets_[bucket].fetch_add(1, std::memory_order_relaxed);
        count_.fetch_add(1, std::memory_order_relaxed);
    }

    void Reset() {
        for (auto& b : buckets_) b.store(0, std::memory_order_relaxed);
        count_.store(0, std::memory_order_relaxed);
    }

    int64_t PercentileMs(double p) const {
        int64_t total = count_.load(std::memory_order_relaxed);
        if (total == 0) return 0;
        int64_t target = static_cast<int64_t>(total * p / 100.0);
        int64_t cumulative = 0;
        for (size_t i = 0; i < NumBuckets; ++i) {
            cumulative += buckets_[i].load(std::memory_order_relaxed);
            if (cumulative >= target) return static_cast<int64_t>((i + 1) * BUCKET_SIZE_MS);
        }
        return MaxLatencyMs;
    }

    int64_t P50Ms() const { return PercentileMs(50); }
    int64_t P90Ms() const { return PercentileMs(90); }
    int64_t P99Ms() const { return PercentileMs(99); }
    int64_t Count() const { return count_.load(std::memory_order_relaxed); }

private:
    std::array<std::atomic<int64_t>, NumBuckets> buckets_;
    std::atomic<int64_t> count_{0};
};

using NetHistogram = LockFreeHistogram<2000, 2000>;      // 1ms buckets up to 2s
using EndToEndHistogram = LockFreeHistogram<2000, 2000>; // 1ms buckets up to 2s

// ???????????????????????????????????????????????????????????????????????????????
// Lock-Free Latency Tracker
// ???????????????????????????????????????????????????????????????????????????????
class LatencyTracker {
public:
    LatencyTracker() : lastReportTime_(HighResTimer::NowMs()) {}

    // ???????????????????????????????????????????????????????????????????????????
    // Recording (all lock-free)
    // ???????????????????????????????????????????????????????????????????????????
    
    // Exchange processing time (transactionTime - eventTime)
    // This is always accurate regardless of local clock!
    void RecordExchangeLatency(int64_t eventTimeMs, int64_t transactionTimeMs) {
        int64_t latencyMs = transactionTimeMs - eventTimeMs;
        // Binance: T >= E always, typical range 0-10ms
        if (latencyMs >= 0 && latencyMs < 1000) {
            exchangeLatency_.RecordMs(latencyMs);
        }
    }
    
    // Network latency (our receive time - exchange transaction time)
    // Requires NTP-synchronized clock!
    void RecordNetworkLatency(int64_t exchangeTimestampMs, int64_t receiveTimeMs) {
        int64_t latencyMs = receiveTimeMs - exchangeTimestampMs;
        // Allow negative values up to -10 sec (clock ahead) and positive up to 10 sec
        if (latencyMs >= -10000 && latencyMs < 10000) {
            networkLatency_.RecordMs(std::abs(latencyMs));
            if (latencyMs >= 0) {
                netHistogram_.RecordMs(latencyMs);
            }
        }
    }
    
    void RecordEnqueueLatencyNs(int64_t ns) { enqueueLatency_.RecordNs(ns); }
    void RecordParseLatency(int64_t ns) { parseLatency_.RecordNs(ns); }
    void RecordProcessLatency(int64_t ns) { processLatency_.RecordNs(ns); }
    void RecordCallbackLatency(int64_t ns) { callbackLatency_.RecordNs(ns); }
    void RecordEndToEndNs(int64_t ns) {
        int64_t ms = ns / 1'000'000;
        endToEndHistogram_.RecordMs(ms);
    }

    void RecordMessage(size_t bytes) {
        messageCount_.fetch_add(1, std::memory_order_relaxed);
        byteCount_.fetch_add(static_cast<int64_t>(bytes), std::memory_order_relaxed);
    }

    // ???????????????????????????????????????????????????????????????????????????
    // Get statistics
    // ???????????????????????????????????????????????????????????????????????????
    
    int64_t GetMessagesPerSecond() {
        int64_t now = HighResTimer::NowMs();
        int64_t elapsed = now - lastReportTime_;
        if (elapsed >= 1000) {
            int64_t msgs = messageCount_.exchange(0, std::memory_order_relaxed);
            byteCount_.exchange(0, std::memory_order_relaxed);
            lastMsgPerSec_ = msgs * 1000 / elapsed;
            lastReportTime_ = now;
        }
        return lastMsgPerSec_;
    }

    void Reset() {
        networkLatency_.Reset();
        exchangeLatency_.Reset();
        enqueueLatency_.Reset();
        parseLatency_.Reset();
        processLatency_.Reset();
        callbackLatency_.Reset();
        netHistogram_.Reset();
        endToEndHistogram_.Reset();
        messageCount_.store(0, std::memory_order_relaxed);
        byteCount_.store(0, std::memory_order_relaxed);
    }

    // ???????????????????????????????????????????????????????????????????????????
    // Output
    // ???????????????????????????????????????????????????????????????????????????
    
    void PrintReport() {
        int64_t msgPerSec = GetMessagesPerSecond();

        std::cout << "\n????????????????????????????????????????????????????????????????????\n";
        std::cout << "?              LATENCY REPORT                                      ?\n";
        std::cout << "????????????????????????????????????????????????????????????????????\n";

        std::cout << "? EXCHANGE (T-E)                                                   ?\n";
        std::cout << "?   Avg: " << std::setw(6) << std::fixed << std::setprecision(1) << exchangeLatency_.AvgMs()
                  << " ms | Min: " << std::setw(4) << exchangeLatency_.MinUs() / 1000
                  << " ms | Max: " << std::setw(4) << exchangeLatency_.MaxUs() / 1000 << " ms         ?\n";

        std::cout << "? NETWORK (recv - T)                                               ?\n";
        std::cout << "?   Avg: " << std::setw(6) << networkLatency_.AvgMs()
                  << " ms | Min: " << std::setw(4) << networkLatency_.MinUs() / 1000
                  << " ms | Max: " << std::setw(4) << networkLatency_.MaxUs() / 1000 << " ms         ?\n";

        std::cout << "? ENQUEUE (recv -> parse start)                                    ?\n";
        std::cout << "?   Avg: " << std::setw(6) << enqueueLatency_.AvgUs()
                  << " us | P50: " << std::setw(4) << enqueueLatency_.MinUs()
                  << " us | P99: " << std::setw(4) << enqueueLatency_.MaxUs() << " us       ?\n";

        std::cout << "? PARSE / PROCESS / CALLBACK (us)                                  ?\n";
        std::cout << "?   Parse: " << std::setw(6) << parseLatency_.AvgUs()
                  << " | Proc: " << std::setw(6) << processLatency_.AvgUs()
                  << " | Cb: " << std::setw(6) << callbackLatency_.AvgUs() << "                ?\n";

        std::cout << "????????????????????????????????????????????????????????????????????\n";
        std::cout << "? E2E: P50=" << std::setw(4) << endToEndHistogram_.P50Ms() << "ms"
                  << " P90=" << std::setw(4) << endToEndHistogram_.P90Ms() << "ms"
                  << " P99=" << std::setw(4) << endToEndHistogram_.P99Ms() << "ms"
                  << "                          ?\n";
        std::cout << "? THROUGHPUT: " << std::setw(5) << msgPerSec << " msg/s"
                  << " | Total: " << std::setw(8) << exchangeLatency_.Count() << " messages"
                  << "              ?\n";
        std::cout << "????????????????????????????????????????????????????????????????????\n";
    }

    std::string GetSummaryString() {
        int64_t msgPerSec = GetMessagesPerSecond();
        std::stringstream ss;
        ss << std::fixed << std::setprecision(1);
        ss << "Exch " << exchangeLatency_.AvgMs() << "ms"
           << " | Net " << networkLatency_.AvgMs() << "ms"
           << " | Eq " << enqueueLatency_.AvgUs() << "us"
           << " | Parse " << parseLatency_.AvgUs() << "us"
           << " | Proc " << processLatency_.AvgUs() << "us"
           << " | Cb " << callbackLatency_.AvgUs() << "us"
           << " | E2E P99 " << endToEndHistogram_.P99Ms() << "ms"
           << " | " << msgPerSec << " msg/s";
        return ss.str();
    }

    int64_t GetEndToEndP99Ms() const { return endToEndHistogram_.P99Ms(); }

private:
    AtomicLatencyStats networkLatency_;
    AtomicLatencyStats exchangeLatency_;
    AtomicLatencyStats enqueueLatency_;
    AtomicLatencyStats parseLatency_;
    AtomicLatencyStats processLatency_;
    AtomicLatencyStats callbackLatency_;

    NetHistogram netHistogram_;
    EndToEndHistogram endToEndHistogram_;

    std::atomic<int64_t> messageCount_{0};
    std::atomic<int64_t> byteCount_{0};
    std::atomic<int64_t> lastMsgPerSec_{0};
    int64_t lastReportTime_;
};

} // namespace hft
