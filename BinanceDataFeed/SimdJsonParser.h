#pragma once

// ???????????????????????????????????????????????????????????????????????????????
// SIMDJSON HIGH-PERFORMANCE JSON PARSER FOR BINANCE
// ???????????????????????????????????????????????????????????????????????????????
// Uses simdjson On-Demand API for zero-copy, streaming JSON parsing
// Optimized for Binance WebSocket message formats
// ???????????????????????????????????????????????????????????????????????????????

// Include simdjson - adjust path based on your setup
#include "../simdjson/simdjson-master/singleheader/simdjson.h"

#include "OrderBook.h"
#include <string>
#include <string_view>
#include <vector>
#include <cstdlib>
#include <charconv>

namespace hft {

// ???????????????????????????????????????????????????????????????????????????????
// Fast string to double conversion (faster than std::stod)
// ???????????????????????????????????????????????????????????????????????????????
inline double FastStringToDouble(std::string_view sv) {
    // Use std::from_chars for maximum performance (C++17)
    double result = 0.0;
    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), result);
    return result;
}

// ???????????????????????????????????????????????????????????????????????????????
// Parsed Depth Update
// ???????????????????????????????????????????????????????????????????????????????
struct ParsedDepthUpdate {
    std::string eventType;
    int64_t eventTime = 0;
    int64_t transactionTime = 0;
    std::string symbol;
    int64_t firstUpdateId = 0;
    int64_t lastUpdateId = 0;
    int64_t prevLastUpdateId = 0;
    
    std::vector<std::pair<double, double>> bids;
    std::vector<std::pair<double, double>> asks;
    
    bool isValid = false;
};

// ???????????????????????????????????????????????????????????????????????????????
// Parsed Book Ticker (Best Bid/Ask)
// ???????????????????????????????????????????????????????????????????????????????
struct ParsedBookTicker {
    std::string eventType;
    int64_t updateId = 0;
    int64_t eventTime = 0;
    int64_t transactionTime = 0;
    std::string symbol;
    
    double bestBidPrice = 0.0;
    double bestBidQty = 0.0;
    double bestAskPrice = 0.0;
    double bestAskQty = 0.0;
    
    bool isValid = false;
};

// ???????????????????????????????????????????????????????????????????????????????
// Parsed Aggregate Trade
// ???????????????????????????????????????????????????????????????????????????????
struct ParsedAggTrade {
    std::string eventType;
    int64_t eventTime = 0;
    int64_t aggregateTradeId = 0;
    std::string symbol;
    
    double price = 0.0;
    double quantity = 0.0;
    int64_t firstTradeId = 0;
    int64_t lastTradeId = 0;
    int64_t tradeTime = 0;
    bool isBuyerMaker = false;
    
    bool isValid = false;
};

// ???????????????????????????????????????????????????????????????????????????????
// Combined Stream Wrapper (for /stream?streams=... endpoint)
// ???????????????????????????????????????????????????????????????????????????????
struct CombinedStreamMessage {
    std::string stream;      // e.g., "btcusdt@depth@100ms"
    std::string_view data;   // raw JSON of inner message
    bool isWrapped = false;  // true if this was a combined stream message
};

// ???????????????????????????????????????????????????????????????????????????????
// SIMDJSON Parser - Thread-safe with per-thread parser instances
// ???????????????????????????????????????????????????????????????????????????????
class SimdJsonParser {
public:
    SimdJsonParser() {
        // Pre-allocate capacity for typical message sizes
        parser_.allocate(64 * 1024);  // 64KB should be enough for most messages
    }
    
    // ???????????????????????????????????????????????????????????????????????????
    // Unwrap Combined Stream Message
    // Format: {"stream":"btcusdt@depth@100ms","data":{...}}
    // ???????????????????????????????????????????????????????????????????????????
    bool UnwrapCombinedStream(const char* json, size_t length, CombinedStreamMessage& out) {
        try {
            auto doc = parser_.iterate(json, length, length + simdjson::SIMDJSON_PADDING);
            
            // Check if this is a combined stream message (has "stream" field)
            std::string_view streamName;
            auto streamErr = doc["stream"].get_string().get(streamName);
            
            if (streamErr) {
                // Not a combined stream message, it's direct
                out.isWrapped = false;
                return false;
            }
            
            out.stream = std::string(streamName);
            out.isWrapped = true;
            
            // Get the raw JSON of the "data" field
            auto dataObj = doc["data"];
            out.data = dataObj.raw_json();
            
            return true;
            
        } catch (...) {
            out.isWrapped = false;
            return false;
        }
    }
    
    // ???????????????????????????????????????????????????????????????????????????
    // Parse Depth Update (diff stream)
    // ???????????????????????????????????????????????????????????????????????????
    bool ParseDepthUpdate(const char* json, size_t length, ParsedDepthUpdate& out) {
        try {
            auto doc = parser_.iterate(json, length, length + simdjson::SIMDJSON_PADDING);
            
            // Get event type first
            std::string_view eventType;
            auto err = doc["e"].get_string().get(eventType);
            if (err || eventType != "depthUpdate") {
                return false;
            }
            
            out.eventType = std::string(eventType);
            out.eventTime = doc["E"].get_int64().value();
            out.transactionTime = doc["T"].get_int64().value();
            
            std::string_view symbol;
            doc["s"].get_string().get(symbol);
            out.symbol = std::string(symbol);
            
            out.firstUpdateId = doc["U"].get_int64().value();
            out.lastUpdateId = doc["u"].get_int64().value();
            out.prevLastUpdateId = doc["pu"].get_int64().value();
            
            // Parse bids
            out.bids.clear();
            auto bidsArray = doc["b"].get_array();
            for (auto bid : bidsArray) {
                auto arr = bid.get_array();
                auto it = arr.begin();
                
                std::string_view priceStr, qtyStr;
                (*it).get_string().get(priceStr);
                ++it;
                (*it).get_string().get(qtyStr);
                
                double price = FastStringToDouble(priceStr);
                double qty = FastStringToDouble(qtyStr);
                
                out.bids.emplace_back(price, qty);
            }
            
            // Parse asks
            out.asks.clear();
            auto asksArray = doc["a"].get_array();
            for (auto ask : asksArray) {
                auto arr = ask.get_array();
                auto it = arr.begin();
                
                std::string_view priceStr, qtyStr;
                (*it).get_string().get(priceStr);
                ++it;
                (*it).get_string().get(qtyStr);
                
                double price = FastStringToDouble(priceStr);
                double qty = FastStringToDouble(qtyStr);
                
                out.asks.emplace_back(price, qty);
            }
            
            out.isValid = true;
            return true;
            
        } catch (...) {
            out.isValid = false;
            return false;
        }
    }
    
    // ???????????????????????????????????????????????????????????????????????????
    // Parse Book Ticker (best bid/ask stream)
    // ???????????????????????????????????????????????????????????????????????????
    bool ParseBookTicker(const char* json, size_t length, ParsedBookTicker& out) {
        try {
            auto doc = parser_.iterate(json, length, length + simdjson::SIMDJSON_PADDING);
            
            // Check event type
            std::string_view eventType;
            auto err = doc["e"].get_string().get(eventType);
            if (err || eventType != "bookTicker") {
                return false;
            }
            
            out.eventType = std::string(eventType);
            out.updateId = doc["u"].get_int64().value();
            out.eventTime = doc["E"].get_int64().value();
            out.transactionTime = doc["T"].get_int64().value();
            
            std::string_view symbol;
            doc["s"].get_string().get(symbol);
            out.symbol = std::string(symbol);
            
            // Parse prices and quantities
            std::string_view str;
            doc["b"].get_string().get(str);
            out.bestBidPrice = FastStringToDouble(str);
            
            doc["B"].get_string().get(str);
            out.bestBidQty = FastStringToDouble(str);
            
            doc["a"].get_string().get(str);
            out.bestAskPrice = FastStringToDouble(str);
            
            doc["A"].get_string().get(str);
            out.bestAskQty = FastStringToDouble(str);
            
            out.isValid = true;
            return true;
            
        } catch (...) {
            out.isValid = false;
            return false;
        }
    }
    
    // ???????????????????????????????????????????????????????????????????????????
    // Parse Aggregate Trade
    // ???????????????????????????????????????????????????????????????????????????
    bool ParseAggTrade(const char* json, size_t length, ParsedAggTrade& out) {
        try {
            auto doc = parser_.iterate(json, length, length + simdjson::SIMDJSON_PADDING);
            
            // Check event type
            std::string_view eventType;
            auto err = doc["e"].get_string().get(eventType);
            if (err || eventType != "aggTrade") {
                return false;
            }
            
            out.eventType = std::string(eventType);
            out.eventTime = doc["E"].get_int64().value();
            out.aggregateTradeId = doc["a"].get_int64().value();
            
            std::string_view symbol;
            doc["s"].get_string().get(symbol);
            out.symbol = std::string(symbol);
            
            std::string_view str;
            doc["p"].get_string().get(str);
            out.price = FastStringToDouble(str);
            
            doc["q"].get_string().get(str);
            out.quantity = FastStringToDouble(str);
            
            out.firstTradeId = doc["f"].get_int64().value();
            out.lastTradeId = doc["l"].get_int64().value();
            out.tradeTime = doc["T"].get_int64().value();
            out.isBuyerMaker = doc["m"].get_bool().value();
            
            out.isValid = true;
            return true;
            
        } catch (...) {
            out.isValid = false;
            return false;
        }
    }
    
    // ???????????????????????????????????????????????????????????????????????????
    // Detect message type (for routing)
    // ???????????????????????????????????????????????????????????????????????????
    enum class MessageType {
        Unknown,
        CombinedStream,  // Wrapped message from /stream?streams=...
        DepthUpdate,
        BookTicker,
        AggTrade,
        MarkPrice,
        Kline,
        MiniTicker,
        Ticker,
        ForceOrder,
        LiquidationOrder
    };
    
    MessageType DetectMessageType(const char* json, size_t length) {
        try {
            auto doc = parser_.iterate(json, length, length + simdjson::SIMDJSON_PADDING);
            
            // First check if this is a combined stream wrapper
            std::string_view streamName;
            if (!doc["stream"].get_string().get(streamName)) {
                return MessageType::CombinedStream;
            }
            
            // Direct message - check event type
            std::string_view eventType;
            auto err = doc["e"].get_string().get(eventType);
            if (err) return MessageType::Unknown;
            
            if (eventType == "depthUpdate") return MessageType::DepthUpdate;
            if (eventType == "bookTicker") return MessageType::BookTicker;
            if (eventType == "aggTrade") return MessageType::AggTrade;
            if (eventType == "markPriceUpdate") return MessageType::MarkPrice;
            if (eventType == "kline") return MessageType::Kline;
            if (eventType == "24hrMiniTicker") return MessageType::MiniTicker;
            if (eventType == "24hrTicker") return MessageType::Ticker;
            if (eventType == "forceOrder") return MessageType::ForceOrder;
            
            return MessageType::Unknown;
            
        } catch (...) {
            return MessageType::Unknown;
        }
    }
    
    // Get string representation of message type
    static const char* MessageTypeToString(MessageType type) {
        switch (type) {
            case MessageType::CombinedStream: return "combinedStream";
            case MessageType::DepthUpdate: return "depthUpdate";
            case MessageType::BookTicker: return "bookTicker";
            case MessageType::AggTrade: return "aggTrade";
            case MessageType::MarkPrice: return "markPriceUpdate";
            case MessageType::Kline: return "kline";
            case MessageType::MiniTicker: return "24hrMiniTicker";
            case MessageType::Ticker: return "24hrTicker";
            case MessageType::ForceOrder: return "forceOrder";
            default: return "unknown";
        }
    }

private:
    simdjson::ondemand::parser parser_;
};

// ???????????????????????????????????????????????????????????????????????????????
// Thread-Local Parser Factory
// Each thread gets its own parser instance for thread safety
// ???????????????????????????????????????????????????????????????????????????????
class ParserPool {
public:
    static SimdJsonParser& GetParser() {
        thread_local SimdJsonParser parser;
        return parser;
    }
};

} // namespace hft
