#pragma once
#include "../Memory/ObjectPool.h"
#include "../Memory/SPSCQueue.h"
#include "OrderTypes.h"

namespace TradingBot::Core::Strategy {

    // ???????????????????????????????????????????????????????????????
    // ѕример использовани€ ObjectPool в Strategy Layer
    // ???????????????????????????????????????????????????????????????

    // 1. Pre-allocated OrderRequest pool дл€ избежани€ heap allocations
    // Memory::ObjectPool<Trading::OrderRequest, 256> orderRequestPool_;

    // 2. SPSC Queue дл€ передачи requests в OMS thread
    // Memory::SPSCQueue<Trading::OrderRequest*, 512> orderQueue_;

    // 3. HOT PATH: √енераци€ ордера (zero allocation)
    /*
    void StrategyEngine::GenerateOrder(double price, double quantity) {
        // Acquire от pool (O(1), lock-free)
        Trading::OrderRequest* request = orderRequestPool_.Acquire();
        
        if (!request) {
            // Pool exhausted (не должно случатьс€)
            LOG_ERROR(LogCategory::STRATEGY, "OrderRequest pool exhausted");
            return;
        }

        // «аполн€ем request
        request->symbol = "BTCUSDT";
        request->side = Trading::Side::BUY;
        request->type = Trading::OrderType::LIMIT;
        request->price = price;
        request->quantity = quantity;
        request->clientOrderId = GenerateOrderId();

        // Push в очередь дл€ OMS thread (lock-free)
        if (!orderQueue_.push(request)) {
            // Queue full (увеличить capacity)
            LOG_WARN(LogCategory::STRATEGY, "Order queue full, dropping order");
            orderRequestPool_.Release(request); // ¬озвращаем в pool
        }
    }
    */

    // 4. OMS Thread: Consumer
    /*
    void OrderManagementSystem::ProcessOrderQueue() {
        Trading::OrderRequest* request;
        
        while (orderQueue_.pop(request)) {
            // ќбрабатываем ордер
            SubmitResult result = SubmitOrder(*request);
            
            // ѕосле использовани€ возвращаем в pool
            orderRequestPool_.Release(request);
        }
    }
    */

    // ???????????????????????????????????????????????????????????????
    // Sizing рекомендации дл€ pools:
    // ???????????????????????????????????????????????????????????????
    // 
    // OrderRequest:     256 (редкие, ~10-100 ордеров/сек)
    // OrderBookUpdate: 512 (частые, ~1000 updates/сек)
    // ExecutionReport: 256 (редкие, response на ордера)
    // Trade:           512 (средн€€ частота, ~500 trades/сек)
    //
    // Pool Size должен быть ЅќЋ№Ў≈ максимального burst размера
    // с запасом на latency spike (например, 2x-3x max burst)

    // ???????????????????????????????????????????????????????????????
    // Queue Capacity рекомендации:
    // ???????????????????????????????????????????????????????????????
    //
    // Network ? Strategy:  1024 (высокий throughput)
    // Strategy ? OMS:      512 (средний throughput)
    // OMS ? Network:       256 (низкий throughput)
    //
    // Capacity должна покрывать latency spike:
    // capacity >= throughput * max_latency_seconds

    // ???????????????????????????????????????????????????????????????
    // Memory overhead:
    // ???????????????????????????????????????????????????????????????
    //
    // ObjectPool<OrderBookUpdate, 512>:
    //   512 * sizeof(OrderBookUpdate) ? 512 * 1KB = 512 KB
    //
    // SPSCQueue<OrderBookUpdate*, 1024>:
    //   1024 * sizeof(void*) = 8 KB (64-bit pointers)
    //
    // Total дл€ типичного bot:
    //   3 pools * 512 KB + 3 queues * 8 KB ? 1.5 MB
    //   (negligible дл€ современных систем)

} // namespace TradingBot::Core::Strategy
