#pragma once
#include <array>
#include <memory>
#include <atomic>
#include <boost/lockfree/stack.hpp>
#include <cstddef>

namespace TradingBot::Core::Memory {

    // ???????????????????????????????????????????????????????????????
    // ObjectPool<T>: Pre-allocated lock-free object pool
    // ???????????????????????????????????????????????????????????????
    // Архитектура:
    // 1. Все объекты выделяются ПРИ СТАРТЕ (pre-allocation)
    // 2. Acquire/Release — O(1), lock-free через boost::lockfree::stack
    // 3. Переиспользование без heap allocations (HOT PATH)
    // ???????????????????????????????????????????????????????????????

    template<typename T, size_t PoolSize = 256>
    class ObjectPool {
    public:
        ObjectPool() {
            // PRE-ALLOCATION: вся память выделяется ЗДЕСЬ
            for (size_t i = 0; i < PoolSize; ++i) {
                pool_[i] = std::make_unique<T>();
                
                // Добавляем в free list (lock-free stack)
                bool success = freeList_.push(pool_[i].get());
                if (!success) {
                    // Не должно случиться (capacity установлена в PoolSize)
                    throw std::runtime_error("ObjectPool: Failed to initialize free list");
                }
            }
            
            availableCount_.store(PoolSize, std::memory_order_release);
        }

        ~ObjectPool() = default;

        // ???????????????????????????????????????????????????????????????
        // Acquire: Получить объект из пула (O(1), lock-free, HOT PATH)
        // ???????????????????????????????????????????????????????????????
        T* Acquire() {
            T* obj = nullptr;
            if (freeList_.pop(obj)) {
                availableCount_.fetch_sub(1, std::memory_order_relaxed);
                return obj;
            }
            
            // Pool exhausted (не должно случаться при правильном sizing)
            return nullptr;
        }

        // ???????????????????????????????????????????????????????????????
        // Release: Вернуть объект в пул (O(1), lock-free)
        // ???????????????????????????????????????????????????????????????
        void Release(T* obj) {
            if (!obj) {
                return;
            }

            // Очистка объекта для переиспользвания (НО не deallocate)
            ResetObject(obj);

            // Возвращаем в free list
            bool success = freeList_.push(obj);
            if (success) {
                availableCount_.fetch_add(1, std::memory_order_relaxed);
            } else {
                // Не должно случиться
                throw std::runtime_error("ObjectPool: Failed to release object");
            }
        }

        // ???????????????????????????????????????????????????????????????
        // Statistics
        // ???????????????????????????????????????????????????????????????
        size_t GetAvailableCount() const {
            return availableCount_.load(std::memory_order_acquire);
        }

        size_t GetCapacity() const {
            return PoolSize;
        }

        size_t GetUsedCount() const {
            return PoolSize - GetAvailableCount();
        }

    private:
        // ???????????????????????????????????????????????????????????????
        // ResetObject: Очистка объекта для переиспользования
        // Специализация через SFINAE для разных типов
        // ???????????????????????????????????????????????????????????????
        
        // Для типов с методом Clear()
        template<typename U = T>
        auto ResetObject(U* obj) -> decltype(obj->Clear(), void()) {
            obj->Clear();
        }

        // Для типов с полями bids/asks (OrderBookUpdate)
        template<typename U = T>
        auto ResetObject(U* obj) -> decltype(obj->bids, obj->asks, void()) {
            obj->bids.clear();  // Не deallocate, только size = 0
            obj->asks.clear();
            obj->u = 0;  // Было lastUpdateId
            obj->U = 0;  // Было firstUpdateId
            obj->E = 0;  // Event time
        }

        // Fallback: ничего не делаем (для POD типов)
        void ResetObject(...) {
            // No-op для типов без специальной очистки
        }

        // ???????????????????????????????????????????????????????????????
        // Members
        // ???????????????????????????????????????????????????????????????
        
        // Storage: все объекты хранятся здесь (pre-allocated)
        std::array<std::unique_ptr<T>, PoolSize> pool_;

        // Free list: lock-free stack для доступных объектов
        // boost::lockfree::stack<T*> использует lock-free алгоритм (CAS)
        boost::lockfree::stack<T*, boost::lockfree::capacity<PoolSize>> freeList_;

        // Statistics: количество доступных объектов
        std::atomic<size_t> availableCount_{0};
    };

    // ???????????????????????????????????????????????????????????????
    // Специализация для OrderBookUpdate (из Types.h)
    // ???????????????????????????????????????????????????????????????
    // Используется в BinanceConnector для переиспользования
    // update объектов без heap allocations в hot path

} // namespace TradingBot::Core::Memory
