#include "AsyncLogger.h"
#include <iostream>
#include <iomanip>
#include <sstream>

namespace TradingBot::Core::Infrastructure {

    // Global logger instance
    AsyncLogger g_Logger;

    AsyncLogger::AsyncLogger() {
        // Конструктор
    }

    AsyncLogger::~AsyncLogger() {
        Stop();
    }

    // ???????????????????????????????????????????????????????????????
    // Start: Запуск логгера
    // ???????????????????????????????????????????????????????????????
    void AsyncLogger::Start(const std::string& logFilePath, LogLevel minLevel) {
        if (running_.load(std::memory_order_acquire)) {
            return; // Уже запущен
        }

        logFilePath_ = logFilePath;
        minLevel_.store(minLevel, std::memory_order_release);

        OpenLogFile(logFilePath_);

        running_.store(true, std::memory_order_release);
        loggerThread_ = std::thread(&AsyncLogger::LoggerThreadFunc, this);

        std::cout << "[AsyncLogger] Started: " << logFilePath_ << std::endl;
    }

    // ???????????????????????????????????????????????????????????????
    // Stop: Остановка логгера
    // ???????????????????????????????????????????????????????????????
    void AsyncLogger::Stop() {
        if (!running_.load(std::memory_order_acquire)) {
            return;
        }

        running_.store(false, std::memory_order_release);

        if (loggerThread_.joinable()) {
            loggerThread_.join();
        }

        if (logFile_.is_open()) {
            logFile_.flush();
            logFile_.close();
        }

        std::cout << "[AsyncLogger] Stopped. Total logs: " << logsWritten_.load()
                  << ", Dropped: " << logsDropped_.load() << std::endl;
    }

    // ???????????????????????????????????????????????????????????????
    // AcquireEntry: Получение слота для записи (lock-free, HOT PATH)
    // ???????????????????????????????????????????????????????????????
    LogEntry* AsyncLogger::AcquireEntry() {
        size_t currentWrite = writeIndex_.load(std::memory_order_relaxed);
        size_t nextWrite = (currentWrite + 1) % RING_BUFFER_SIZE;

        size_t currentRead = readIndex_.load(std::memory_order_acquire);

        // Проверяем, не переполнен ли буфер
        if (nextWrite == currentRead) {
            logsDropped_.fetch_add(1, std::memory_order_relaxed);
            return nullptr; // Буфер полон
        }

        return &ringBuffer_[currentWrite];
    }

    // ???????????????????????????????????????????????????????????????
    // Commit: Фиксация записи (lock-free)
    // ???????????????????????????????????????????????????????????????
    void AsyncLogger::Commit(LogEntry* entry) {
        if (!entry) {
            return;
        }

        // Продвигаем writeIndex
        size_t currentWrite = writeIndex_.load(std::memory_order_relaxed);
        size_t nextWrite = (currentWrite + 1) % RING_BUFFER_SIZE;
        writeIndex_.store(nextWrite, std::memory_order_release);
    }

    // ???????????????????????????????????????????????????????????????
    // LoggerThreadFunc: Background thread (consumer)
    // ???????????????????????????????????????????????????????????????
    void AsyncLogger::LoggerThreadFunc() {
        while (running_.load(std::memory_order_acquire)) {
            size_t currentRead = readIndex_.load(std::memory_order_relaxed);
            size_t currentWrite = writeIndex_.load(std::memory_order_acquire);

            if (currentRead == currentWrite) {
                // Буфер пуст, ждём
                std::this_thread::sleep_for(std::chrono::microseconds(100));
                continue;
            }

            // Обрабатываем запись
            const LogEntry& entry = ringBuffer_[currentRead];
            WriteEntry(entry);

            // Продвигаем readIndex
            size_t nextRead = (currentRead + 1) % RING_BUFFER_SIZE;
            readIndex_.store(nextRead, std::memory_order_release);

            logsWritten_.fetch_add(1, std::memory_order_relaxed);

            // Проверяем ротацию файла
            if (currentFileSizeBytes_ >= rotationSizeBytes_) {
                RotateLogFile();
            }
        }

        // Финальная очистка буфера перед выходом
        size_t currentRead = readIndex_.load(std::memory_order_relaxed);
        size_t currentWrite = writeIndex_.load(std::memory_order_acquire);
        while (currentRead != currentWrite) {
            const LogEntry& entry = ringBuffer_[currentRead];
            WriteEntry(entry);
            currentRead = (currentRead + 1) % RING_BUFFER_SIZE;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // OpenLogFile: Открытие файла лога
    // ???????????????????????????????????????????????????????????????
    void AsyncLogger::OpenLogFile(const std::string& path) {
        logFile_.open(path, std::ios::out | std::ios::app);
        if (!logFile_.is_open()) {
            std::cerr << "[AsyncLogger] ERROR: Failed to open log file: " << path << std::endl;
        }
        currentFileSizeBytes_ = 0;
    }

    // ???????????????????????????????????????????????????????????????
    // RotateLogFile: Ротация файла
    // ???????????????????????????????????????????????????????????????
    void AsyncLogger::RotateLogFile() {
        if (logFile_.is_open()) {
            logFile_.flush();
            logFile_.close();
        }

        // Переименовываем старый файл
        auto now = std::chrono::system_clock::now();
        auto nowTime = std::chrono::system_clock::to_time_t(now);
        std::ostringstream oss;
        oss << logFilePath_ << "." << std::put_time(std::localtime(&nowTime), "%Y%m%d_%H%M%S");

        std::rename(logFilePath_.c_str(), oss.str().c_str());

        // Открываем новый файл
        OpenLogFile(logFilePath_);
    }

    // ???????????????????????????????????????????????????????????????
    // WriteEntry: Запись в файл
    // ???????????????????????????????????????????????????????????????
    void AsyncLogger::WriteEntry(const LogEntry& entry) {
        if (!logFile_.is_open()) {
            return;
        }

        // Формат: 2026-01-06T12:34:56.789|INFO|OMS|Message
        std::string timestamp = FormatTimestamp(entry.timestampNs);
        const char* level = LevelToString(entry.level);
        const char* category = CategoryToString(entry.category);

        std::ostringstream oss;
        oss << timestamp << "|" << level << "|" << category << "|" << entry.message;

        // Добавляем structured fields если есть
        if (entry.price > 0.0) {
            oss << " price=" << std::fixed << std::setprecision(2) << entry.price;
        }
        if (entry.quantity > 0.0) {
            oss << " qty=" << std::fixed << std::setprecision(8) << entry.quantity;
        }
        if (entry.orderId > 0) {
            oss << " orderId=" << entry.orderId;
        }

        oss << "\n";

        std::string logLine = oss.str();
        logFile_ << logLine;
        logFile_.flush();

        currentFileSizeBytes_ += logLine.size();
    }

    // ???????????????????????????????????????????????????????????????
    // Helpers
    // ???????????????????????????????????????????????????????????????

    const char* AsyncLogger::LevelToString(LogLevel level) const {
        switch (level) {
        case LogLevel::TRACE: return "TRACE";
        case LogLevel::DEBUG: return "DEBUG";
        case LogLevel::INFO:  return "INFO";
        case LogLevel::WARN:  return "WARN";
        case LogLevel::ERR:   return "ERROR";  // Было ERROR, теперь ERR
        case LogLevel::FATAL: return "FATAL";
        default: return "UNKNOWN";
        }
    }

    const char* AsyncLogger::CategoryToString(LogCategory category) const {
        switch (category) {
        case LogCategory::NETWORK:   return "NETWORK";
        case LogCategory::ORDERBOOK: return "ORDERBOOK";
        case LogCategory::STRATEGY:  return "STRATEGY";
        case LogCategory::OMS:       return "OMS";
        case LogCategory::RISK:      return "RISK";
        case LogCategory::TELEMETRY: return "TELEMETRY";
        default: return "UNKNOWN";
        }
    }

    std::string AsyncLogger::FormatTimestamp(uint64_t timestampNs) const {
        auto ms = timestampNs / 1000000;
        auto us = (timestampNs / 1000) % 1000;

        auto tp = std::chrono::system_clock::time_point(std::chrono::milliseconds(ms));
        auto tt = std::chrono::system_clock::to_time_t(tp);

        std::ostringstream oss;
        oss << std::put_time(std::localtime(&tt), "%Y-%m-%dT%H:%M:%S")
            << "." << std::setfill('0') << std::setw(3) << (ms % 1000);

        return oss.str();
    }

} // namespace TradingBot::Core::Infrastructure
