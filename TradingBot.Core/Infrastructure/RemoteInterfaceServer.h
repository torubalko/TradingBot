#pragma once
#include <cstdint>
#include <string>
#include <memory>
#include <atomic>
#include <thread>
#include <boost/asio.hpp>

namespace TradingBot::Core::Infrastructure {

    namespace asio = boost::asio;
    using tcp = asio::ip::tcp;

    // ???????????????????????????????????????????????????????????????
    // MessageType: Типы сообщений для UI
    // ???????????????????????????????????????????????????????????????
    enum class MessageType : uint16_t {
        OrderBook  = 1,
        Trade      = 2,
        Position   = 3,
        Telemetry  = 4,
        OrderUpdate = 5
    };

    // ???????????????????????????????????????????????????????????????
    // CommandType: Команды от UI
    // ???????????????????????????????????????????????????????????????
    enum class CommandType : uint16_t {
        SubscribeSymbol   = 1,
        UnsubscribeSymbol = 2,
        SetRiskParam      = 10,
        PauseStrategy     = 20,
        ResumeStrategy    = 21,
        RequestSnapshot   = 30,
        CancelAllOrders   = 40
    };

    // ???????????????????????????????????????????????????????????????
    // MessageHeader: Заголовок бинарного сообщения
    // ???????????????????????????????????????????????????????????????
    #pragma pack(push, 1)
    struct MessageHeader {
        uint32_t length{0};       // Длина payload
        uint16_t messageType{0};  // MessageType
        uint16_t version{1};      // Версия протокола
    };
    #pragma pack(pop)

    // ???????????????????????????????????????????????????????????????
    // OrderBookMessage: Сообщение с order book данными
    // ???????????????????????????????????????????????????????????????
    #pragma pack(push, 1)
    struct OrderBookMessage {
        MessageHeader header;
        uint64_t timestampNs{0};
        uint16_t symbolId{0};
        uint16_t bidCount{0};
        uint16_t askCount{0};
        uint16_t padding{0};
        // Followed by: PriceLevel[bidCount + askCount]
    };

    struct PriceLevel {
        double price{0.0};
        double quantity{0.0};
    };
    #pragma pack(pop)

    // ???????????????????????????????????????????????????????????????
    // TradeMessage: Сообщение о трейде
    // ???????????????????????????????????????????????????????????????
    #pragma pack(push, 1)
    struct TradeMessage {
        MessageHeader header;
        uint64_t tradeId{0};
        uint16_t symbolId{0};
        uint8_t isBuyerMaker{0};
        uint8_t padding[5]{};
        double price{0.0};
        double quantity{0.0};
        uint64_t timestampNs{0};
    };
    #pragma pack(pop)

    // ???????????????????????????????????????????????????????????????
    // TelemetryMessage: Телеметрия для UI
    // ???????????????????????????????????????????????????????????????
    #pragma pack(push, 1)
    struct TelemetryMessage {
        MessageHeader header;
        uint64_t timestampNs{0};
        uint64_t wsToParseLatencyP50{0};
        uint64_t wsToParseLatencyP99{0};
        uint32_t messagesPerSecond{0};
        uint32_t updatesPerSecond{0};
        double realizedPnL{0.0};
        double unrealizedPnL{0.0};
        double currentExposure{0.0};
        uint32_t activeOrders{0};
        uint8_t riskState{0};
        uint8_t padding[3]{};
    };
    #pragma pack(pop)

    // ???????????????????????????????????????????????????????????????
    // RemoteInterfaceServer: TCP сервер для UI
    // ???????????????????????????????????????????????????????????????
    class RemoteInterfaceServer {
    public:
        RemoteInterfaceServer(uint16_t port = 9999);
        ~RemoteInterfaceServer();

        // ???????????????????????????????????????????????????????????????
        // Start/Stop
        // ???????????????????????????????????????????????????????????????
        void Start();
        void Stop();

        // ???????????????????????????????????????????????????????????????
        // Send Messages to UI (throttled)
        // ???????????????????????????????????????????????????????????????
        void SendOrderBook(const OrderBookMessage& message);
        void SendTrade(const TradeMessage& message);
        void SendTelemetry(const TelemetryMessage& message);

        // ???????????????????????????????????????????????????????????????
        // Command Handler (callback для обработки команд от UI)
        // ???????????????????????????????????????????????????????????????
        using CommandCallback = std::function<void(CommandType, const std::vector<uint8_t>&)>;
        void SetCommandCallback(CommandCallback callback) {
            commandCallback_ = callback;
        }

    private:
        // ???????????????????????????????????????????????????????????????
        // Accept Loop
        // ???????????????????????????????????????????????????????????????
        void AcceptLoop();

        // ???????????????????????????????????????????????????????????????
        // Client Session
        // ???????????????????????????????????????????????????????????????
        void HandleClient(std::shared_ptr<tcp::socket> socket);

        // ???????????????????????????????????????????????????????????????
        // Throttling
        // ???????????????????????????????????????????????????????????????
        bool ShouldSendOrderBook();  // Max 20 Hz (50ms)

        // ???????????????????????????????????????????????????????????????
        // Members
        // ???????????????????????????????????????????????????????????????
        uint16_t port_;
        std::atomic<bool> running_{false};

        asio::io_context ioContext_;
        std::unique_ptr<tcp::acceptor> acceptor_;
        std::thread serverThread_;

        // Connected client (single client для упрощения)
        std::shared_ptr<tcp::socket> clientSocket_;

        // Callback для команд
        CommandCallback commandCallback_;

        // Throttling state
        std::atomic<uint64_t> lastOrderBookSendNs_{0};
        static constexpr uint64_t ORDER_BOOK_THROTTLE_NS = 50'000'000; // 50ms = 20 Hz
    };

} // namespace TradingBot::Core::Infrastructure
