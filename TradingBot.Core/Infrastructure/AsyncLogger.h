#pragma once
#include <cstdint>
#include <atomic>
#include <thread>
#include <fstream>
#include <chrono>
#include <array>
#include <string_view>

namespace TradingBot::Core::Infrastructure {

    // ???????????????????????????????????????????????????????????????
    // LogLevel: Уровни логирования
    // ???????????????????????????????????????????????????????????????
    enum class LogLevel : uint8_t {
        TRACE = 0,  // Детальная отладка
        DEBUG = 1,  // Отладка
        INFO  = 2,  // Информация
        WARN  = 3,  // Предупреждения
        ERR   = 4,  // Ошибки (было ERROR, конфликт с Windows.h)
        FATAL = 5   // Критические (остановка)
    };

    // ???????????????????????????????????????????????????????????????
    // LogCategory: Категории логов
    // ???????????????????????????????????????????????????????????????
    enum class LogCategory : uint16_t {
        NETWORK   = 1,
        ORDERBOOK = 2,
        STRATEGY  = 3,
        OMS       = 4,
        RISK      = 5,
        TELEMETRY = 6
    };

    // ???????????????????????????????????????????????????????????????
    // LogEntry: Структура записи лога (pre-allocated, fixed size)
    // ???????????????????????????????????????????????????????????????
    struct alignas(64) LogEntry {
        uint64_t timestampNs{0};
        LogLevel level{LogLevel::INFO};
        LogCategory category{LogCategory::NETWORK};
        char message[256]{};  // Fixed-size buffer (cache-line friendly)

        // Optional structured fields
        double price{0.0};
        double quantity{0.0};
        uint64_t orderId{0};
    };

    // ???????????????????????????????????????????????????????????????
    // AsyncLogger: Lock-free асинхронный логгер
    // Архитектура: SPSC Queue (Single Producer, Single Consumer)
    // ???????????????????????????????????????????????????????????????
    class AsyncLogger {
    public:
        AsyncLogger();
        ~AsyncLogger();

        // ???????????????????????????????????????????????????????????????
        // Initialization
        // ???????????????????????????????????????????????????????????????
        void Start(const std::string& logFilePath, LogLevel minLevel = LogLevel::INFO);
        void Stop();

        // ???????????????????????????????????????????????????????????????
        // Log Entry Acquisition (lock-free, HOT PATH)
        // ???????????????????????????????????????????????????????????????
        LogEntry* AcquireEntry();
        void Commit(LogEntry* entry);

        // ???????????????????????????????????????????????????????????????
        // Should Log Check (compile-time optimization)
        // ???????????????????????????????????????????????????????????????
        bool ShouldLog(LogLevel level) const {
            return level >= minLevel_.load(std::memory_order_relaxed);
        }

        // ???????????????????????????????????????????????????????????????
        // Configuration
        // ???????????????????????????????????????????????????????????????
        void SetMinLevel(LogLevel level) {
            minLevel_.store(level, std::memory_order_release);
        }

        void SetRotationSize(size_t sizeBytes) {
            rotationSizeBytes_ = sizeBytes;
        }

        // ???????????????????????????????????????????????????????????????
        // Statistics
        // ???????????????????????????????????????????????????????????????
        uint64_t GetTotalLogsWritten() const {
            return logsWritten_.load(std::memory_order_relaxed);
        }

        uint64_t GetDroppedLogs() const {
            return logsDropped_.load(std::memory_order_relaxed);
        }

    private:
        // ???????????????????????????????????????????????????????????????
        // Background Thread (consumer)
        // ???????????????????????????????????????????????????????????????
        void LoggerThreadFunc();

        // ???????????????????????????????????????????????????????????????
        // File Operations
        // ???????????????????????????????????????????????????????????????
        void OpenLogFile(const std::string& path);
        void RotateLogFile();
        void WriteEntry(const LogEntry& entry);

        // ???????????????????????????????????????????????????????????????
        // Helpers
        // ???????????????????????????????????????????????????????????????
        const char* LevelToString(LogLevel level) const;
        const char* CategoryToString(LogCategory category) const;
        std::string FormatTimestamp(uint64_t timestampNs) const;

        // ???????????????????????????????????????????????????????????????
        // SPSC Ring Buffer (lock-free)
        // ???????????????????????????????????????????????????????????????
        static constexpr size_t RING_BUFFER_SIZE = 16384; // 16K entries (power of 2)
        std::array<LogEntry, RING_BUFFER_SIZE> ringBuffer_;

        alignas(64) std::atomic<size_t> writeIndex_{0};  // Producer writes here
        alignas(64) std::atomic<size_t> readIndex_{0};   // Consumer reads here

        // ???????????????????????????????????????????????????????????????
        // Logger Thread
        // ???????????????????????????????????????????????????????????????
        std::thread loggerThread_;
        std::atomic<bool> running_{false};

        // ???????????????????????????????????????????????????????????????
        // File Handling
        // ???????????????????????????????????????????????????????????????
        std::ofstream logFile_;
        std::string logFilePath_;
        size_t currentFileSizeBytes_{0};
        size_t rotationSizeBytes_{100 * 1024 * 1024}; // 100 MB default

        // ???????????????????????????????????????????????????????????????
        // Configuration
        // ???????????????????????????????????????????????????????????????
        std::atomic<LogLevel> minLevel_{LogLevel::INFO};

        // ???????????????????????????????????????????????????????????????
        // Statistics
        // ???????????????????????????????????????????????????????????????
        std::atomic<uint64_t> logsWritten_{0};
        std::atomic<uint64_t> logsDropped_{0};
    };

    // ???????????????????????????????????????????????????????????????
    // Global Logger Instance
    // ???????????????????????????????????????????????????????????????
    extern AsyncLogger g_Logger;

    // ???????????????????????????????????????????????????????????????
    // Logging Macros (zero-allocation, compile-time optimization)
    // ???????????????????????????????????????????????????????????????

    inline uint64_t GetNanoseconds() {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();
    }

    #define LOG_TRACE(cat, fmt, ...) \
        do { \
            if (::TradingBot::Core::Infrastructure::g_Logger.ShouldLog(::TradingBot::Core::Infrastructure::LogLevel::TRACE)) { \
                auto* e = ::TradingBot::Core::Infrastructure::g_Logger.AcquireEntry(); \
                if (e) { \
                    e->timestampNs = ::TradingBot::Core::Infrastructure::GetNanoseconds(); \
                    e->level = ::TradingBot::Core::Infrastructure::LogLevel::TRACE; \
                    e->category = cat; \
                    snprintf(e->message, sizeof(e->message), fmt, ##__VA_ARGS__); \
                    ::TradingBot::Core::Infrastructure::g_Logger.Commit(e); \
                } \
            } \
        } while(0)

    #define LOG_DEBUG(cat, fmt, ...) \
        do { \
            if (::TradingBot::Core::Infrastructure::g_Logger.ShouldLog(::TradingBot::Core::Infrastructure::LogLevel::DEBUG)) { \
                auto* e = ::TradingBot::Core::Infrastructure::g_Logger.AcquireEntry(); \
                if (e) { \
                    e->timestampNs = ::TradingBot::Core::Infrastructure::GetNanoseconds(); \
                    e->level = ::TradingBot::Core::Infrastructure::LogLevel::DEBUG; \
                    e->category = cat; \
                    snprintf(e->message, sizeof(e->message), fmt, ##__VA_ARGS__); \
                    ::TradingBot::Core::Infrastructure::g_Logger.Commit(e); \
                } \
            } \
        } while(0)

    #define LOG_INFO(cat, fmt, ...) \
        do { \
            if (::TradingBot::Core::Infrastructure::g_Logger.ShouldLog(::TradingBot::Core::Infrastructure::LogLevel::INFO)) { \
                auto* e = ::TradingBot::Core::Infrastructure::g_Logger.AcquireEntry(); \
                if (e) { \
                    e->timestampNs = ::TradingBot::Core::Infrastructure::GetNanoseconds(); \
                    e->level = ::TradingBot::Core::Infrastructure::LogLevel::INFO; \
                    e->category = cat; \
                    snprintf(e->message, sizeof(e->message), fmt, ##__VA_ARGS__); \
                    ::TradingBot::Core::Infrastructure::g_Logger.Commit(e); \
                } \
            } \
        } while(0)

    #define LOG_WARN(cat, fmt, ...) \
        do { \
            if (::TradingBot::Core::Infrastructure::g_Logger.ShouldLog(::TradingBot::Core::Infrastructure::LogLevel::WARN)) { \
                auto* e = ::TradingBot::Core::Infrastructure::g_Logger.AcquireEntry(); \
                if (e) { \
                    e->timestampNs = ::TradingBot::Core::Infrastructure::GetNanoseconds(); \
                    e->level = ::TradingBot::Core::Infrastructure::LogLevel::WARN; \
                    e->category = cat; \
                    snprintf(e->message, sizeof(e->message), fmt, ##__VA_ARGS__); \
                    ::TradingBot::Core::Infrastructure::g_Logger.Commit(e); \
                } \
            } \
        } while(0)

    #define LOG_ERROR(cat, fmt, ...) \
        do { \
            if (::TradingBot::Core::Infrastructure::g_Logger.ShouldLog(::TradingBot::Core::Infrastructure::LogLevel::ERR)) { \
                auto* e = ::TradingBot::Core::Infrastructure::g_Logger.AcquireEntry(); \
                if (e) { \
                    e->timestampNs = ::TradingBot::Core::Infrastructure::GetNanoseconds(); \
                    e->level = ::TradingBot::Core::Infrastructure::LogLevel::ERR; \
                    e->category = cat; \
                    snprintf(e->message, sizeof(e->message), fmt, ##__VA_ARGS__); \
                    ::TradingBot::Core::Infrastructure::g_Logger.Commit(e); \
                } \
            } \
        } while(0)

    #define LOG_FATAL(cat, fmt, ...) \
        do { \
            auto* e = ::TradingBot::Core::Infrastructure::g_Logger.AcquireEntry(); \
            if (e) { \
                e->timestampNs = ::TradingBot::Core::Infrastructure::GetNanoseconds(); \
                e->level = ::TradingBot::Core::Infrastructure::LogLevel::FATAL; \
                e->category = cat; \
                snprintf(e->message, sizeof(e->message), fmt, ##__VA_ARGS__); \
                ::TradingBot::Core::Infrastructure::g_Logger.Commit(e); \
            } \
        } while(0)

} // namespace TradingBot::Core::Infrastructure
