#include "TelemetryCollector.h"
#include <iostream>
#include <iomanip>
#include <vector>

namespace TradingBot::Core::Infrastructure {

    TelemetryCollector::TelemetryCollector() {
        // Инициализация: заполняем буферы нулями
        wsToParseLatencies_.fill(0);
        parseToUpdateLatencies_.fill(0);
        orderRoundtripLatencies_.fill(0);
    }

    // ???????????????????????????????????????????????????????????????
    // RecordWsToParseLatency: Запись latency (lock-free)
    // ???????????????????????????????????????????????????????????????
    void TelemetryCollector::RecordWsToParseLatency(uint64_t latencyNs) {
        size_t index = wsToParseIndex_.fetch_add(1, std::memory_order_relaxed) % LATENCY_BUFFER_SIZE;
        wsToParseLatencies_[index] = latencyNs;
    }

    void TelemetryCollector::RecordParseToUpdateLatency(uint64_t latencyNs) {
        size_t index = parseToUpdateIndex_.fetch_add(1, std::memory_order_relaxed) % LATENCY_BUFFER_SIZE;
        parseToUpdateLatencies_[index] = latencyNs;
    }

    void TelemetryCollector::RecordOrderRoundtripLatency(uint64_t latencyNs) {
        size_t index = orderRoundtripIndex_.fetch_add(1, std::memory_order_relaxed) % LATENCY_BUFFER_SIZE;
        orderRoundtripLatencies_[index] = latencyNs;
    }

    // ???????????????????????????????????????????????????????????????
    // GetSnapshot: Генерация снимка метрик
    // ???????????????????????????????????????????????????????????????
    TelemetrySnapshot TelemetryCollector::GetSnapshot() {
        TelemetrySnapshot snapshot;

        // Latency (percentiles)
        snapshot.wsToParseLatencyP50 = CalculatePercentile(wsToParseLatencies_, 0.50);
        snapshot.wsToParseLatencyP99 = CalculatePercentile(wsToParseLatencies_, 0.99);
        snapshot.parseToUpdateLatencyP50 = CalculatePercentile(parseToUpdateLatencies_, 0.50);
        snapshot.orderRoundtripLatencyP50 = CalculatePercentile(orderRoundtripLatencies_, 0.50);

        // Throughput (delta от прошлого snapshot)
        uint64_t currentMessages = messagesReceived_.load(std::memory_order_relaxed);
        uint64_t currentUpdates = updatesProcessed_.load(std::memory_order_relaxed);
        uint64_t currentOrders = ordersSubmitted_.load(std::memory_order_relaxed);

        snapshot.messagesPerSecond = static_cast<uint32_t>(currentMessages - lastMessagesReceived_.load());
        snapshot.updatesPerSecond = static_cast<uint32_t>(currentUpdates - lastUpdatesProcessed_.load());
        snapshot.ordersPerMinute = static_cast<uint32_t>(currentOrders - lastOrdersSubmitted_.load());

        // Trading state
        snapshot.realizedPnL = realizedPnL_.load(std::memory_order_relaxed);
        snapshot.unrealizedPnL = unrealizedPnL_.load(std::memory_order_relaxed);
        snapshot.currentExposure = currentExposure_.load(std::memory_order_relaxed);
        snapshot.activeOrders = activeOrders_.load(std::memory_order_relaxed);

        // Risk state
        snapshot.riskState = riskState_.load(std::memory_order_relaxed);
        snapshot.dailyLossUsed = dailyLossUsed_.load(std::memory_order_relaxed);
        snapshot.positionUsed = positionUsed_.load(std::memory_order_relaxed);

        // System (TODO: реальные значения)
        snapshot.memoryUsedBytes = 0;
        snapshot.queueDepthNetwork = 0;
        snapshot.queueDepthStrategy = 0;

        return snapshot;
    }

    // ???????????????????????????????????????????????????????????????
    // ResetThroughputCounters: Сброс счётчиков (каждую секунду)
    // ???????????????????????????????????????????????????????????????
    void TelemetryCollector::ResetThroughputCounters() {
        lastMessagesReceived_.store(messagesReceived_.load(), std::memory_order_relaxed);
        lastUpdatesProcessed_.store(updatesProcessed_.load(), std::memory_order_relaxed);
        lastOrdersSubmitted_.store(ordersSubmitted_.load(), std::memory_order_relaxed);
    }

    // ???????????????????????????????????????????????????????????????
    // PrintSnapshot: Pretty print в консоль
    // ???????????????????????????????????????????????????????????????
    void TelemetryCollector::PrintSnapshot(const TelemetrySnapshot& snapshot) const {
        // Конвертация latency в microseconds для читаемости
        double wsToParseUs = snapshot.wsToParseLatencyP50 / 1000.0;
        double parseToUpdateUs = snapshot.parseToUpdateLatencyP50 / 1000.0;
        double totalLatencyUs = wsToParseUs + parseToUpdateUs;

        // Форматирование PnL
        double totalPnL = snapshot.realizedPnL + snapshot.unrealizedPnL;
        const char* pnlSign = (totalPnL >= 0) ? "+" : "";

        // Risk state
        const char* riskStateStr = "NORMAL";
        switch (snapshot.riskState) {
        case Trading::RiskState::Normal: riskStateStr = "NORMAL"; break;
        case Trading::RiskState::ReduceOnly: riskStateStr = "REDUCE_ONLY"; break;
        case Trading::RiskState::Halted: riskStateStr = "HALTED"; break;
        }

        // Вывод
        std::cout << "????????????????????????????????????????????????????????????" << std::endl;
        std::cout << "? BTCUSDT ? Latency: " << std::fixed << std::setprecision(1) << totalLatencyUs << "µs"
                  << " ? PnL: " << pnlSign << std::fixed << std::setprecision(2) << totalPnL << " USDT"
                  << " ? Orders: " << snapshot.ordersPerMinute << "/min ?" << std::endl;

        std::cout << "? Pos: " << std::fixed << std::setprecision(2) << snapshot.positionUsed << "%"
                  << " ? Exposure: " << std::fixed << std::setprecision(0) << snapshot.currentExposure << " USDT"
                  << " ? Risk: " << riskStateStr
                  << " ? Loss: " << std::fixed << std::setprecision(0) << snapshot.dailyLossUsed << "% ?" << std::endl;

        std::cout << "????????????????????????????????????????????????????????????" << std::endl;
    }

    // ???????????????????????????????????????????????????????????????
    // CalculatePercentile: Вычисление percentile из буфера
    // ???????????????????????????????????????????????????????????????
    uint64_t TelemetryCollector::CalculatePercentile(
        const std::array<uint64_t, LATENCY_BUFFER_SIZE>& data,
        double percentile) const
    {
        // Копируем данные для сортировки (не хотим модифицировать оригинал)
        std::vector<uint64_t> sorted;
        sorted.reserve(LATENCY_BUFFER_SIZE);

        for (uint64_t value : data) {
            if (value > 0) {  // Пропускаем нулевые значения
                sorted.push_back(value);
            }
        }

        if (sorted.empty()) {
            return 0;
        }

        std::sort(sorted.begin(), sorted.end());

        size_t index = static_cast<size_t>(sorted.size() * percentile);
        if (index >= sorted.size()) {
            index = sorted.size() - 1;
        }

        return sorted[index];
    }

} // namespace TradingBot::Core::Infrastructure
