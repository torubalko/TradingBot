#include "RemoteInterfaceServer.h"
#include "AsyncLogger.h"
#include <iostream>
#include <chrono>

namespace TradingBot::Core::Infrastructure {

    RemoteInterfaceServer::RemoteInterfaceServer(uint16_t port)
        : port_(port)
    {
    }

    RemoteInterfaceServer::~RemoteInterfaceServer() {
        Stop();
    }

    // ???????????????????????????????????????????????????????????????
    // Start: Запуск TCP сервера
    // ???????????????????????????????????????????????????????????????
    void RemoteInterfaceServer::Start() {
        if (running_.load(std::memory_order_acquire)) {
            return;
        }

        try {
            acceptor_ = std::make_unique<tcp::acceptor>(
                ioContext_,
                tcp::endpoint(tcp::v4(), port_)
            );

            running_.store(true, std::memory_order_release);
            serverThread_ = std::thread(&RemoteInterfaceServer::AcceptLoop, this);

            std::cout << "[RemoteInterfaceServer] Started on port " << port_ << std::endl;

        } catch (const std::exception& e) {
            std::cerr << "[RemoteInterfaceServer] Failed to start: " << e.what() << std::endl;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // Stop: Остановка сервера
    // ???????????????????????????????????????????????????????????????
    void RemoteInterfaceServer::Stop() {
        if (!running_.load(std::memory_order_acquire)) {
            return;
        }

        running_.store(false, std::memory_order_release);

        if (clientSocket_ && clientSocket_->is_open()) {
            clientSocket_->close();
        }

        ioContext_.stop();

        if (serverThread_.joinable()) {
            serverThread_.join();
        }

        std::cout << "[RemoteInterfaceServer] Stopped" << std::endl;
    }

    // ???????????????????????????????????????????????????????????????
    // AcceptLoop: Цикл приёма подключений
    // ???????????????????????????????????????????????????????????????
    void RemoteInterfaceServer::AcceptLoop() {
        while (running_.load(std::memory_order_acquire)) {
            try {
                auto socket = std::make_shared<tcp::socket>(ioContext_);
                acceptor_->accept(*socket);

                std::cout << "[RemoteInterfaceServer] Client connected: "
                          << socket->remote_endpoint().address().to_string() << std::endl;

                // Закрываем предыдущий клиент (single client mode)
                if (clientSocket_ && clientSocket_->is_open()) {
                    clientSocket_->close();
                }

                clientSocket_ = socket;

                // Запускаем обработку команд от клиента
                std::thread(&RemoteInterfaceServer::HandleClient, this, socket).detach();

            } catch (const std::exception& e) {
                if (running_.load(std::memory_order_acquire)) {
                    std::cerr << "[RemoteInterfaceServer] Accept error: " << e.what() << std::endl;
                }
            }
        }
    }

    // ???????????????????????????????????????????????????????????????
    // HandleClient: Обработка команд от клиента
    // ???????????????????????????????????????????????????????????????
    void RemoteInterfaceServer::HandleClient(std::shared_ptr<tcp::socket> socket) {
        try {
            while (socket->is_open() && running_.load(std::memory_order_acquire)) {
                // Читаем header (8 bytes)
                MessageHeader header;
                boost::asio::read(*socket, boost::asio::buffer(&header, sizeof(header)));

                // Читаем payload
                std::vector<uint8_t> payload(header.length);
                if (header.length > 0) {
                    boost::asio::read(*socket, boost::asio::buffer(payload));
                }

                // Обрабатываем команду
                if (commandCallback_) {
                    CommandType cmdType = static_cast<CommandType>(header.messageType);
                    commandCallback_(cmdType, payload);
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "[RemoteInterfaceServer] Client disconnected" << std::endl;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // SendOrderBook: Отправка order book (throttled)
    // ???????????????????????????????????????????????????????????????
    void RemoteInterfaceServer::SendOrderBook(const OrderBookMessage& message) {
        if (!clientSocket_ || !clientSocket_->is_open()) {
            return;
        }

        if (!ShouldSendOrderBook()) {
            return; // Throttled
        }

        try {
            boost::asio::write(*clientSocket_, boost::asio::buffer(&message, sizeof(message)));
        } catch (const std::exception& e) {
            std::cerr << "[RemoteInterfaceServer] Send error: " << e.what() << std::endl;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // SendTrade: Отправка трейда (pass-through, без throttling)
    // ???????????????????????????????????????????????????????????????
    void RemoteInterfaceServer::SendTrade(const TradeMessage& message) {
        if (!clientSocket_ || !clientSocket_->is_open()) {
            return;
        }

        try {
            boost::asio::write(*clientSocket_, boost::asio::buffer(&message, sizeof(message)));
        } catch (const std::exception& e) {
            std::cerr << "[RemoteInterfaceServer] Send error: " << e.what() << std::endl;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // SendTelemetry: Отправка телеметрии (1 Hz)
    // ???????????????????????????????????????????????????????????????
    void RemoteInterfaceServer::SendTelemetry(const TelemetryMessage& message) {
        if (!clientSocket_ || !clientSocket_->is_open()) {
            return;
        }

        try {
            boost::asio::write(*clientSocket_, boost::asio::buffer(&message, sizeof(message)));
        } catch (const std::exception& e) {
            std::cerr << "[RemoteInterfaceServer] Send error: " << e.what() << std::endl;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // ShouldSendOrderBook: Throttling check (20 Hz = 50ms)
    // ???????????????????????????????????????????????????????????????
    bool RemoteInterfaceServer::ShouldSendOrderBook() {
        uint64_t nowNs = std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();

        uint64_t lastSend = lastOrderBookSendNs_.load(std::memory_order_relaxed);

        if (nowNs - lastSend < ORDER_BOOK_THROTTLE_NS) {
            return false; // Too soon
        }

        lastOrderBookSendNs_.store(nowNs, std::memory_order_relaxed);
        return true;
    }

} // namespace TradingBot::Core::Infrastructure
