#include "SnapshotSynchronizer.h"
#include <iostream>

namespace TradingBot::Core::OrderBook {

    SnapshotSynchronizer::SnapshotSynchronizer(LocalOrderBook& orderBook)
        : orderBook_(orderBook)
    {
        // Конструктор
    }

    // ???????????????????????????????????????????????????????????????
    // Start: Начало синхронизации
    // ???????????????????????????????????????????????????????????????
    void SnapshotSynchronizer::Start() {
        TransitionTo(SyncState::Buffering);
        snapshotRequested_ = false;
        diffBuffer_.clear();
        lastUpdateId_.store(0, std::memory_order_release);

        std::cout << "[SnapshotSynchronizer] Started: Buffering mode" << std::endl;
    }

    void SnapshotSynchronizer::Stop() {
        TransitionTo(SyncState::Disconnected);
        diffBuffer_.clear();
    }

    void SnapshotSynchronizer::Reset() {
        Stop();
        orderBook_.Clear();
        lastUpdateId_.store(0, std::memory_order_release);
        snapshotRequested_ = false;
    }

    // ???????????????????????????????????????????????????????????????
    // OnDepthUpdate: Входящее diff-обновление (HOT PATH)
    // ???????????????????????????????????????????????????????????????
    void SnapshotSynchronizer::OnDepthUpdate(const OrderBookUpdate& update) {
        SyncState currentState = GetState();

        switch (currentState) {
        case SyncState::Buffering:
            // ЭТАП 1: Буферизация
            BufferUpdate(update);
            
            // После некоторого количества обновлений запрашиваем snapshot
            if (!snapshotRequested_ && diffBuffer_.size() >= 10) {
                RequestSnapshot();
            }
            break;

        case SyncState::AwaitingSnapshot:
            // Продолжаем буферизацию во время ожидания snapshot
            BufferUpdate(update);
            break;

        case SyncState::Synchronizing:
            // Во время синхронизации продолжаем буферизацию
            BufferUpdate(update);
            break;

        case SyncState::Live:
            // ЭТАП 4: Применение live updates
            ApplyLiveUpdate(update);
            break;

        case SyncState::Resync:
            // При resync сбрасываем и начинаем заново
            Reset();
            Start();
            BufferUpdate(update);
            break;

        default:
            break;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // OnSnapshot: Входящий REST snapshot
    // ???????????????????????????????????????????????????????????????
    void SnapshotSynchronizer::OnSnapshot(const OrderBookSnapshot& snapshot) {
        if (GetState() != SyncState::AwaitingSnapshot && 
            GetState() != SyncState::Buffering) {
            return;
        }

        std::cout << "[SnapshotSynchronizer] Snapshot received: lastUpdateId=" 
                  << snapshot.lastUpdateId << std::endl;

        // Применяем snapshot к LocalOrderBook
        orderBook_.ApplySnapshot(snapshot.bids, snapshot.asks);

        // Переходим к синхронизации буфера
        TransitionTo(SyncState::Synchronizing);

        // ЭТАП 3: Синхронизация buffered diffs
        SynchronizeBuffer(snapshot.lastUpdateId);
    }

    // ???????????????????????????????????????????????????????????????
    // ЭТАП 1: Буферизация diff-обновлений
    // ???????????????????????????????????????????????????????????????
    void SnapshotSynchronizer::BufferUpdate(const OrderBookUpdate& update) {
        // Ограничиваем размер буфера
        if (diffBuffer_.size() >= maxBufferSize_) {
            // Удаляем самое старое обновление
            diffBuffer_.pop_front();
        }

        DiffBufferEntry entry;
        entry.firstUpdateId = update.U;
        entry.finalUpdateId = update.u;
        entry.update = update; // Копируем данные

        diffBuffer_.push_back(entry);
    }

    // ???????????????????????????????????????????????????????????????
    // ЭТАП 2: Запрос snapshot
    // ???????????????????????????????????????????????????????????????
    void SnapshotSynchronizer::RequestSnapshot() {
        if (snapshotRequested_) {
            return;
        }

        snapshotRequested_ = true;
        TransitionTo(SyncState::AwaitingSnapshot);

        std::cout << "[SnapshotSynchronizer] Requesting snapshot..." << std::endl;

        // Вызываем callback для запроса snapshot через REST
        if (snapshotRequestCallback_) {
            snapshotRequestCallback_();
        }
    }

    // ???????????????????????????????????????????????????????????????
    // ЭТАП 3: Синхронизация buffered diffs со snapshot
    // ???????????????????????????????????????????????????????????????
    void SnapshotSynchronizer::SynchronizeBuffer(int64_t snapshotLastUpdateId) {
        std::cout << "[SnapshotSynchronizer] Synchronizing buffer: "
                  << diffBuffer_.size() << " diffs" << std::endl;

        int appliedCount = 0;
        int skippedCount = 0;

        for (auto& entry : diffBuffer_) {
            // Пропускаем слишком старые обновления
            if (entry.finalUpdateId <= snapshotLastUpdateId) {
                skippedCount++;
                continue;
            }

            // Проверяем валидность первого обновления
            if (appliedCount == 0) {
                // Первое валидное обновление:
                // firstUpdateId <= snapshotLastUpdateId + 1 <= finalUpdateId
                if (entry.firstUpdateId > snapshotLastUpdateId + 1) {
                    std::cerr << "[SnapshotSynchronizer] GAP DETECTED! Expected <= "
                              << (snapshotLastUpdateId + 1)
                              << ", got " << entry.firstUpdateId << std::endl;

                    // GAP обнаружен - требуется пересинхронизация
                    TransitionTo(SyncState::Resync);
                    return;
                }
            }

            // Применяем обновление
            orderBook_.ApplyUpdate(entry.update.bids, entry.update.asks);
            lastUpdateId_.store(entry.finalUpdateId, std::memory_order_release);
            appliedCount++;
        }

        std::cout << "[SnapshotSynchronizer] Synchronized: applied=" << appliedCount
                  << ", skipped=" << skippedCount << std::endl;

        // Очищаем буфер
        diffBuffer_.clear();

        // Переходим в Live режим
        TransitionTo(SyncState::Live);
    }

    // ???????????????????????????????????????????????????????????????
    // ЭТАП 4: Применение live updates
    // ???????????????????????????????????????????????????????????????
    void SnapshotSynchronizer::ApplyLiveUpdate(const OrderBookUpdate& update) {
        // Проверяем непрерывность: prev_final_id + 1 == current_first_id
        int64_t prevUpdateId = lastUpdateId_.load(std::memory_order_acquire);

        if (prevUpdateId > 0 && update.U != prevUpdateId + 1) {
            std::cerr << "[SnapshotSynchronizer] GAP in live updates! "
                      << "Expected firstUpdateId=" << (prevUpdateId + 1)
                      << ", got " << update.U << std::endl;

            // Обнаружен gap - требуется пересинхронизация
            TransitionTo(SyncState::Resync);
            return;
        }

        // Применяем обновление
        orderBook_.ApplyUpdate(update.bids, update.asks);
        lastUpdateId_.store(update.u, std::memory_order_release);
    }

    // ???????????????????????????????????????????????????????????????
    // State Transition
    // ???????????????????????????????????????????????????????????????
    void SnapshotSynchronizer::TransitionTo(SyncState newState) {
        SyncState oldState = state_.exchange(newState, std::memory_order_acq_rel);

        if (oldState != newState) {
            std::cout << "[SnapshotSynchronizer] State: " 
                      << static_cast<int>(oldState) << " -> " 
                      << static_cast<int>(newState) << std::endl;

            if (stateChangeCallback_) {
                stateChangeCallback_(newState);
            }
        }
    }

    // ???????????????????????????????????????????????????????????????
    // Gap Detection
    // ???????????????????????????????????????????????????????????????
    bool SnapshotSynchronizer::DetectGap(int64_t firstUpdateId) const {
        int64_t lastId = lastUpdateId_.load(std::memory_order_acquire);
        return (lastId > 0 && firstUpdateId != lastId + 1);
    }

} // namespace TradingBot::Core::OrderBook
