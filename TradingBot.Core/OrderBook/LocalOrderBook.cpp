#include "LocalOrderBook.h"

namespace TradingBot::Core::OrderBook {

    // ???????????????????????????????????????????????????????????????
    // ApplySnapshot: Полная замена стакана (REST snapshot)
    // ???????????????????????????????????????????????????????????????
    void LocalOrderBook::ApplySnapshot(const std::vector<OrderBookLevel>& bids,
                                       const std::vector<OrderBookLevel>& asks) {
        // Очищаем старые данные
        bids_.clear();
        asks_.clear();

        // Копируем новые данные
        bids_.reserve(bids.size());
        asks_.reserve(asks.size());

        for (const auto& level : bids) {
            bids_.push_back({level.price, level.quantity});
        }

        for (const auto& level : asks) {
            asks_.push_back({level.price, level.quantity});
        }

        // Сортировка: bids DESC (лучшая цена первая)
        std::sort(bids_.begin(), bids_.end(), 
            [](const PriceLevel& a, const PriceLevel& b) {
                return a.price > b.price;
            });

        // Сортировка: asks ASC (лучшая цена первая)
        std::sort(asks_.begin(), asks_.end(),
            [](const PriceLevel& a, const PriceLevel& b) {
                return a.price < b.price;
            });
    }

    // ???????????????????????????????????????????????????????????????
    // ApplyUpdate: Инкрементальное обновление (WebSocket diff)
    // HOT PATH - критичная производительность!
    // ???????????????????????????????????????????????????????????????
    void LocalOrderBook::ApplyUpdate(const std::vector<OrderBookLevel>& bidUpdates,
                                     const std::vector<OrderBookLevel>& askUpdates) {
        // Обновляем Bids
        for (const auto& update : bidUpdates) {
            if (update.quantity < EPSILON) {
                // Удаление уровня (quantity == 0)
                RemoveBid(update.price);
            } else {
                // Обновление или вставка
                UpsertBid({update.price, update.quantity});
            }
        }

        // Обновляем Asks
        for (const auto& update : askUpdates) {
            if (update.quantity < EPSILON) {
                RemoveAsk(update.price);
            } else {
                UpsertAsk({update.price, update.quantity});
            }
        }
    }

    // ???????????????????????????????????????????????????????????????
    // UpsertBid: Binary search + in-place update (DESC сортировка)
    // ???????????????????????????????????????????????????????????????
    void LocalOrderBook::UpsertBid(const PriceLevel& level) {
        // Binary search для DESC сортировки
        auto it = std::lower_bound(bids_.begin(), bids_.end(), level,
            [](const PriceLevel& a, const PriceLevel& b) {
                return a.price > b.price; // DESC
            });

        // Проверяем, существует ли уже этот уровень
        if (it != bids_.end() && std::abs(it->price - level.price) < EPSILON) {
            // Обновление существующего уровня
            it->quantity = level.quantity;
        } else {
            // Вставка нового уровня
            bids_.insert(it, level);
        }
    }

    // ???????????????????????????????????????????????????????????????
    // UpsertAsk: Binary search + in-place update (ASC сортировка)
    // ???????????????????????????????????????????????????????????????
    void LocalOrderBook::UpsertAsk(const PriceLevel& level) {
        // Binary search для ASC сортировки
        auto it = std::lower_bound(asks_.begin(), asks_.end(), level,
            [](const PriceLevel& a, const PriceLevel& b) {
                return a.price < b.price; // ASC
            });

        if (it != asks_.end() && std::abs(it->price - level.price) < EPSILON) {
            it->quantity = level.quantity;
        } else {
            asks_.insert(it, level);
        }
    }

    // ???????????????????????????????????????????????????????????????
    // RemoveBid: Удаление bid по цене
    // ???????????????????????????????????????????????????????????????
    void LocalOrderBook::RemoveBid(double price) {
        PriceLevel temp{price, 0.0};
        
        auto it = std::lower_bound(bids_.begin(), bids_.end(), temp,
            [](const PriceLevel& a, const PriceLevel& b) {
                return a.price > b.price; // DESC
            });

        if (it != bids_.end() && std::abs(it->price - price) < EPSILON) {
            bids_.erase(it);
        }
    }

    // ???????????????????????????????????????????????????????????????
    // RemoveAsk: Удаление ask по цене
    // ???????????????????????????????????????????????????????????????
    void LocalOrderBook::RemoveAsk(double price) {
        PriceLevel temp{price, 0.0};

        auto it = std::lower_bound(asks_.begin(), asks_.end(), temp,
            [](const PriceLevel& a, const PriceLevel& b) {
                return a.price < b.price; // ASC
            });

        if (it != asks_.end() && std::abs(it->price - price) < EPSILON) {
            asks_.erase(it);
        }
    }

} // namespace TradingBot::Core::OrderBook
