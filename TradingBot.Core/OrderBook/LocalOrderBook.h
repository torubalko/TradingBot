#pragma once
#include <vector>
#include <algorithm>
#include <cmath>
#include "../Types.h"

namespace TradingBot::Core::OrderBook {

    // ???????????????????????????????????????????????????????????????
    // PriceLevel: Уровень цены в стакане
    // ???????????????????????????????????????????????????????????????
    struct PriceLevel {
        double price{0.0};
        double quantity{0.0};

        // Для binary search и сортировки
        bool operator<(const PriceLevel& other) const {
            return price < other.price;
        }
    };

    // ???????????????????????????????????????????????????????????????
    // LocalOrderBook: Локальная копия стакана с эффективным обновлением
    // ???????????????????????????????????????????????????????????????
    class LocalOrderBook {
    public:
        // ???????????????????????????????????????????????????????????????
        // Constructor: PRE-ALLOCATION
        // ???????????????????????????????????????????????????????????????
        LocalOrderBook() {
            // Worst Case: 10,000 уровней цены
            bids_.reserve(10000);
            asks_.reserve(10000);
        }

        // ???????????????????????????????????????????????????????????????
        // Применение REST snapshot (полная замена стакана)
        // ???????????????????????????????????????????????????????????????
        void ApplySnapshot(const std::vector<OrderBookLevel>& bids,
                          const std::vector<OrderBookLevel>& asks);

        // ???????????????????????????????????????????????????????????????
        // Применение WebSocket diff (HOT PATH!)
        // Инкрементальное обновление без полной замены
        // ???????????????????????????????????????????????????????????????
        void ApplyUpdate(const std::vector<OrderBookLevel>& bidUpdates,
                        const std::vector<OrderBookLevel>& askUpdates);

        // ???????????????????????????????????????????????????????????????
        // Read-only доступ к данным
        // ???????????????????????????????????????????????????????????????
        const std::vector<PriceLevel>& GetBids() const { return bids_; }
        const std::vector<PriceLevel>& GetAsks() const { return asks_; }

        double GetBestBid() const {
            return bids_.empty() ? 0.0 : bids_.front().price;
        }

        double GetBestAsk() const {
            return asks_.empty() ? 0.0 : asks_.front().price;
        }

        double GetMidPrice() const {
            double bestBid = GetBestBid();
            double bestAsk = GetBestAsk();
            if (bestBid > 0.0 && bestAsk > 0.0) {
                return (bestBid + bestAsk) / 2.0;
            }
            return 0.0;
        }

        double GetSpread() const {
            double bestBid = GetBestBid();
            double bestAsk = GetBestAsk();
            if (bestBid > 0.0 && bestAsk > 0.0) {
                return bestAsk - bestBid;
            }
            return 0.0;
        }

        // Очистка стакана
        void Clear() {
            bids_.clear();
            asks_.clear();
        }

        // Статистика
        size_t GetBidDepth() const { return bids_.size(); }
        size_t GetAskDepth() const { return asks_.size(); }

    private:
        // ???????????????????????????????????????????????????????????????
        // Internal Helpers: Binary Search + In-place Modification
        // O(log N) для поиска, O(N) в худшем случае для вставки/удаления
        // ???????????????????????????????????????????????????????????????

        // Обновить или вставить bid (DESC сортировка)
        void UpsertBid(const PriceLevel& level);

        // Обновить или вставить ask (ASC сортировка)
        void UpsertAsk(const PriceLevel& level);

        // Удалить bid по цене
        void RemoveBid(double price);

        // Удалить ask по цене
        void RemoveAsk(double price);

        // Epsilon для сравнения double
        static constexpr double EPSILON = 1e-8;

        // ???????????????????????????????????????????????????????????????
        // Data Members
        // ???????????????????????????????????????????????????????????????
        // Bids: отсортированы по убыванию цены (лучшая цена первая)
        std::vector<PriceLevel> bids_;

        // Asks: отсортированы по возрастанию цены (лучшая цена первая)
        std::vector<PriceLevel> asks_;
    };

} // namespace TradingBot::Core::OrderBook
