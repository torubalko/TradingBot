#pragma once
#include <array>
#include <unordered_map>
#include <span>
#include <atomic>
#include "OrderTypes.h"
#include "RiskManager.h"
#include "RestExecutor.h"

namespace TradingBot::Core::Trading {

    // ???????????????????????????????????????????????????????????????
    // OrderManagementSystem: ѕолный жизненный цикл ордера
    // ???????????????????????????????????????????????????????????????
    class OrderManagementSystem {
    public:
        OrderManagementSystem(RestExecutor& executor, RiskManager& riskManager);
        ~OrderManagementSystem() = default;

        // ???????????????????????????????????????????????????????????????
        // Order Submission (через RiskManager)
        // ???????????????????????????????????????????????????????????????
        SubmitResult SubmitOrder(const OrderRequest& request);

        // ???????????????????????????????????????????????????????????????
        // Order Cancellation
        // ???????????????????????????????????????????????????????????????
        CancelResult CancelOrder(uint64_t clientOrderId);

        // ???????????????????????????????????????????????????????????????
        // Order Replacement (atomic cancel + new)
        // ???????????????????????????????????????????????????????????????
        SubmitResult ReplaceOrder(uint64_t clientOrderId, double newPrice);

        // ???????????????????????????????????????????????????????????????
        // Execution Report Processing (от UserDataStream)
        // ???????????????????????????????????????????????????????????????
        void ProcessExecutionReport(const ExecutionReport& report);

        // ???????????????????????????????????????????????????????????????
        // Chasing: автоматическое перемещение лимитки за рынком
        // ???????????????????????????????????????????????????????????????
        void EnableChasing(uint64_t clientOrderId, double maxSlippage);
        void DisableChasing(uint64_t clientOrderId);

        // ???????????????????????????????????????????????????????????????
        // Access to Active Orders
        // ???????????????????????????????????????????????????????????????
        std::span<const LiveOrder> GetActiveOrders() const {
            return std::span<const LiveOrder>(orderPool_.data(), activeCount_.load());
        }

        const LiveOrder* GetOrder(uint64_t clientOrderId) const;

        size_t GetActiveOrderCount() const {
            return activeCount_.load(std::memory_order_acquire);
        }

    private:
        // ???????????????????????????????????????????????????????????????
        // Internal Helpers
        // ???????????????????????????????????????????????????????????????
        
        // √енераци€ уникального clientOrderId (timestamp-based)
        uint64_t GenerateClientOrderId();

        // ƒобавление ордера в pool
        size_t AllocateOrder(const OrderRequest& request);

        // ќбновление ордера в pool
        void UpdateOrder(size_t index, const ExecutionReport& report);

        // ”даление ордера из pool
        void RemoveOrder(uint64_t clientOrderId);

        // ???????????????????????????????????????????????????????????????
        // Members
        // ???????????????????????????????????????????????????????????????
        RestExecutor& restExecutor_;
        RiskManager& riskManager_;

        // PRE-ALLOCATED pool дл€ активных ордеров
        std::array<LiveOrder, 256> orderPool_;
        std::atomic<size_t> activeCount_{0};

        // Index: clientOrderId ? slot in pool
        std::unordered_map<uint64_t, size_t> orderIndex_;

        // Chasing state
        std::unordered_map<uint64_t, double> chasingOrders_; // clientOrderId -> maxSlippage
    };

} // namespace TradingBot::Core::Trading
