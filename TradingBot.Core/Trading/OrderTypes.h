#pragma once
#include <cstdint>
#include <string>
#include <string_view>

namespace TradingBot::Core::Trading {

    // ???????????????????????????????????????????????????????????????
    // Order Side
    // ???????????????????????????????????????????????????????????????
    enum class Side {
        BUY,
        SELL
    };

    // ???????????????????????????????????????????????????????????????
    // Order Type
    // ???????????????????????????????????????????????????????????????
    enum class OrderType {
        LIMIT,
        MARKET,
        LIMIT_MAKER,    // Post-only
        STOP_LOSS,
        STOP_LOSS_LIMIT,
        TAKE_PROFIT,
        TAKE_PROFIT_LIMIT
    };

    // ???????????????????????????????????????????????????????????????
    // Time In Force
    // ???????????????????????????????????????????????????????????????
    enum class TimeInForce {
        GTC,  // Good Till Cancel
        IOC,  // Immediate Or Cancel
        FOK   // Fill Or Kill
    };

    // ???????????????????????????????????????????????????????????????
    // Order State
    // ???????????????????????????????????????????????????????????????
    enum class OrderState {
        Pending,         // Локально создан, ещё не отправлен
        Sent,            // Отправлен на биржу, ждём подтверждения
        Open,            // Активен на бирже
        PartiallyFilled, // Частично исполнен
        Filled,          // Полностью исполнен
        Canceled,        // Отменён
        Rejected,        // Отклонён биржей
        Expired          // Истёк (GTD orders)
    };

    // ???????????????????????????????????????????????????????????????
    // OrderRequest: Запрос на создание ордера
    // ???????????????????????????????????????????????????????????????
    struct OrderRequest {
        uint64_t clientOrderId{0};    // Генерируется локально (timestamp-based)
        std::string_view symbol;      // "BTCUSDT"
        Side side{Side::BUY};
        OrderType type{OrderType::LIMIT};
        TimeInForce tif{TimeInForce::GTC};
        double price{0.0};
        double quantity{0.0};
        uint64_t createTimeNs{0};
    };

    // ???????????????????????????????????????????????????????????????
    // LiveOrder: Активный ордер
    // ???????????????????????????????????????????????????????????????
    struct LiveOrder {
        uint64_t clientOrderId{0};
        uint64_t exchangeOrderId{0};  // Присваивается биржей
        OrderState state{OrderState::Pending};
        std::string symbol;           // Копия для хранения
        Side side{Side::BUY};
        OrderType type{OrderType::LIMIT};
        double originalQty{0.0};
        double executedQty{0.0};
        double avgPrice{0.0};
        uint64_t lastUpdateTimeNs{0};
    };

    // ???????????????????????????????????????????????????????????????
    // ExecutionReport: Отчёт об исполнении (от UserDataStream)
    // ???????????????????????????????????????????????????????????????
    struct ExecutionReport {
        uint64_t clientOrderId{0};
        uint64_t exchangeOrderId{0};
        std::string symbol;
        OrderState state{OrderState::Pending};
        double originalQty{0.0};
        double executedQty{0.0};
        double price{0.0};
        double avgPrice{0.0};
        uint64_t timestampMs{0};
    };

    // ???????????????????????????????????????????????????????????????
    // Helper: Order State to String
    // ???????????????????????????????????????????????????????????????
    inline const char* OrderStateToString(OrderState state) {
        switch (state) {
        case OrderState::Pending: return "PENDING";
        case OrderState::Sent: return "SENT";
        case OrderState::Open: return "OPEN";
        case OrderState::PartiallyFilled: return "PARTIALLY_FILLED";
        case OrderState::Filled: return "FILLED";
        case OrderState::Canceled: return "CANCELED";
        case OrderState::Rejected: return "REJECTED";
        case OrderState::Expired: return "EXPIRED";
        default: return "UNKNOWN";
        }
    }

    inline const char* SideToString(Side side) {
        return (side == Side::BUY) ? "BUY" : "SELL";
    }

    inline const char* OrderTypeToString(OrderType type) {
        switch (type) {
        case OrderType::LIMIT: return "LIMIT";
        case OrderType::MARKET: return "MARKET";
        case OrderType::LIMIT_MAKER: return "LIMIT_MAKER";
        case OrderType::STOP_LOSS: return "STOP_LOSS";
        case OrderType::STOP_LOSS_LIMIT: return "STOP_LOSS_LIMIT";
        case OrderType::TAKE_PROFIT: return "TAKE_PROFIT";
        case OrderType::TAKE_PROFIT_LIMIT: return "TAKE_PROFIT_LIMIT";
        default: return "UNKNOWN";
        }
    }

    inline const char* TimeInForceToString(TimeInForce tif) {
        switch (tif) {
        case TimeInForce::GTC: return "GTC";
        case TimeInForce::IOC: return "IOC";
        case TimeInForce::FOK: return "FOK";
        default: return "UNKNOWN";
        }
    }

} // namespace TradingBot::Core::Trading
