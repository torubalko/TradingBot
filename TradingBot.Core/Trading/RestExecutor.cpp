#include "RestExecutor.h"
#include <sstream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <iostream>
#include <openssl/hmac.h>
#include <openssl/evp.h>

namespace TradingBot::Core::Trading {

    RestExecutor::RestExecutor(const ApiConfig& config)
        : config_(config)
    {
        // Создаём HTTP клиент
        httpClient_ = std::make_unique<Network::HttpClient>();
        httpClient_->SetTimeout(config_.requestTimeoutMs);
    }

    // ???????????????????????????????????????????????????????????????
    // TestConnection: Проверка связи с Binance API
    // ???????????????????????????????????????????????????????????????
    bool RestExecutor::TestConnection() {
        try {
            auto response = httpClient_->Get(config_.spotHost, "/api/v3/ping");
            
            if (response.IsSuccess()) {
                std::cout << "[RestExecutor] Connection test SUCCESS" << std::endl;
                return true;
            } else {
                std::cerr << "[RestExecutor] Connection test FAILED: " 
                          << response.errorMessage << std::endl;
                return false;
            }
        } catch (const std::exception& e) {
            std::cerr << "[RestExecutor] Connection test EXCEPTION: " << e.what() << std::endl;
            return false;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // SubmitOrder: Отправка ордера на биржу
    // ???????????????????????????????????????????????????????????????
    SubmitResult RestExecutor::SubmitOrder(const OrderRequest& order) {
        SubmitResult result;

        try {
            // 1. Строим query string
            std::string queryString = BuildOrderQueryString(order);

            // 2. Добавляем timestamp
            uint64_t timestamp = GetTimestampMs();
            queryString += "&timestamp=" + std::to_string(timestamp);

            // 3. Генерируем подпись (только если есть API ключи)
            if (!config_.apiKey.empty()) {
                std::string signature = GenerateSignature(queryString);
                queryString += "&signature=" + signature;
            }

            // 4. HTTP POST с retry
            std::string endpoint = "/api/v3/order";
            auto response = PostRequest(endpoint, queryString);

            if (!response.IsSuccess()) {
                result.success = false;
                result.errorMessage = "HTTP " + std::to_string(response.statusCode) + 
                                     ": " + response.body;
                return result;
            }

            // 5. Парсим JSON ответ (TODO: использовать simdjson для production)
            // Пока упрощённый парсинг
            std::string body = response.body;
            
            // Ищем orderId в JSON
            size_t orderIdPos = body.find("\"orderId\":");
            if (orderIdPos != std::string::npos) {
                size_t startPos = orderIdPos + 10;
                size_t endPos = body.find_first_of(",}", startPos);
                std::string orderIdStr = body.substr(startPos, endPos - startPos);
                result.exchangeOrderId = std::stoull(orderIdStr);
                result.success = true;
            } else {
                result.success = false;
                result.errorMessage = "Failed to parse orderId from response";
            }

        } catch (const std::exception& e) {
            result.success = false;
            result.errorMessage = e.what();
        }

        return result;
    }

    // ???????????????????????????????????????????????????????????????
    // CancelOrder: Отмена ордера
    // ???????????????????????????????????????????????????????????????
    CancelResult RestExecutor::CancelOrder(std::string_view symbol, uint64_t clientOrderId) {
        CancelResult result;

        try {
            // 1. Строим query string
            std::ostringstream oss;
            oss << "symbol=" << symbol
                << "&origClientOrderId=" << clientOrderId
                << "&timestamp=" << GetTimestampMs();

            std::string queryString = oss.str();

            // 2. Генерируем подпись
            if (!config_.apiKey.empty()) {
                std::string signature = GenerateSignature(queryString);
                queryString += "&signature=" + signature;
            }

            // 3. HTTP DELETE с retry
            std::string endpoint = "/api/v3/order";
            auto response = DeleteRequest(endpoint, queryString);

            result.success = response.IsSuccess();
            if (!result.success) {
                result.errorMessage = "HTTP " + std::to_string(response.statusCode) + 
                                     ": " + response.body;
            }

        } catch (const std::exception& e) {
            result.success = false;
            result.errorMessage = e.what();
        }

        return result;
    }

    // ???????????????????????????????????????????????????????????????
    // QueryOrder: Запрос статуса ордера
    // ???????????????????????????????????????????????????????????????
    ExecutionReport RestExecutor::QueryOrder(std::string_view symbol, uint64_t clientOrderId) {
        ExecutionReport report;

        try {
            // 1. Строим query string
            std::ostringstream oss;
            oss << "symbol=" << symbol
                << "&origClientOrderId=" << clientOrderId
                << "&timestamp=" << GetTimestampMs();

            std::string queryString = oss.str();

            // 2. Генерируем подпись
            if (!config_.apiKey.empty()) {
                std::string signature = GenerateSignature(queryString);
                queryString += "&signature=" + signature;
            }

            // 3. HTTP GET
            std::string endpoint = "/api/v3/order";
            auto response = GetRequest(endpoint, queryString);

            if (response.IsSuccess()) {
                // TODO: Парсинг JSON в ExecutionReport
                // Пока заглушка
            }

        } catch (const std::exception& e) {
            std::cerr << "[RestExecutor] QueryOrder error: " << e.what() << std::endl;
        }

        return report;
    }

    // ???????????????????????????????????????????????????????????????
    // PostRequest: HTTP POST с retry
    // ???????????????????????????????????????????????????????????????
    Network::HttpResponse RestExecutor::PostRequest(const std::string& endpoint, 
                                                    const std::string& queryString) {
        return ExecuteWithRetry([&]() {
            std::string target = endpoint + "?" + queryString;
            return httpClient_->Post(config_.spotHost, target, "", config_.apiKey);
        });
    }

    // ???????????????????????????????????????????????????????????????
    // GetRequest: HTTP GET с retry
    // ???????????????????????????????????????????????????????????????
    Network::HttpResponse RestExecutor::GetRequest(const std::string& endpoint,
                                                   const std::string& queryString) {
        return ExecuteWithRetry([&]() {
            std::string target = endpoint + "?" + queryString;
            return httpClient_->Get(config_.spotHost, target, config_.apiKey);
        });
    }

    // ???????????????????????????????????????????????????????????????
    // DeleteRequest: HTTP DELETE с retry
    // ???????????????????????????????????????????????????????????????
    Network::HttpResponse RestExecutor::DeleteRequest(const std::string& endpoint,
                                                      const std::string& queryString) {
        return ExecuteWithRetry([&]() {
            std::string target = endpoint + "?" + queryString;
            return httpClient_->Delete(config_.spotHost, target, config_.apiKey);
        });
    }

    // ???????????????????????????????????????????????????????????????
    // ExecuteWithRetry: Retry logic с exponential backoff
    // ???????????????????????????????????????????????????????????????
    Network::HttpResponse RestExecutor::ExecuteWithRetry(
        std::function<Network::HttpResponse()> requestFunc)
    {
        Network::HttpResponse response;
        int delayMs = config_.retryDelayMs;

        for (int attempt = 0; attempt < config_.maxRetries; ++attempt) {
            response = requestFunc();

            if (response.IsSuccess()) {
                return response; // Success
            }

            // Retry на 5xx ошибках или сетевых проблемах
            if (response.statusCode >= 500 || response.statusCode == 0) {
                if (attempt < config_.maxRetries - 1) {
                    std::cerr << "[RestExecutor] Retry " << (attempt + 1) 
                              << "/" << config_.maxRetries 
                              << " after " << delayMs << "ms" << std::endl;

                    std::this_thread::sleep_for(std::chrono::milliseconds(delayMs));
                    delayMs *= 2; // Exponential backoff
                }
            } else {
                // 4xx ошибки не ретраим (client error)
                break;
            }
        }

        return response;
    }

    // ???????????????????????????????????????????????????????????????
    // GenerateSignature: HMAC-SHA256
    // ???????????????????????????????????????????????????????????????
    std::string RestExecutor::GenerateSignature(const std::string& queryString) const {
        unsigned char hash[EVP_MAX_MD_SIZE];
        unsigned int hashLen = 0;

        HMAC(EVP_sha256(),
             config_.secretKey.c_str(), config_.secretKey.size(),
             reinterpret_cast<const unsigned char*>(queryString.c_str()), queryString.size(),
             hash, &hashLen);

        // Convert to hex string
        std::ostringstream oss;
        for (unsigned int i = 0; i < hashLen; ++i) {
            oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
        }

        return oss.str();
    }

    // ???????????????????????????????????????????????????????????????
    // BuildOrderQueryString: Построение query string для ордера
    // ???????????????????????????????????????????????????????????????
    std::string RestExecutor::BuildOrderQueryString(const OrderRequest& order) const {
        std::ostringstream oss;
        
        // Параметры должны быть отсортированы лексикографически (Binance требует)
        oss << "symbol=" << order.symbol;
        oss << "&side=" << SideToString(order.side);
        oss << "&type=" << OrderTypeToString(order.type);
        oss << "&timeInForce=" << TimeInForceToString(order.tif);
        
        // Форматируем quantity с нужной точностью
        oss << "&quantity=" << std::fixed << std::setprecision(8) << order.quantity;
        
        if (order.price > 0.0) {
            oss << "&price=" << std::fixed << std::setprecision(2) << order.price;
        }
        
        oss << "&newClientOrderId=" << order.clientOrderId;
        oss << "&recvWindow=5000"; // 5 секунд

        return oss.str();
    }

    // ???????????????????????????????????????????????????????????????
    // GetTimestampMs: Текущий timestamp в миллисекундах
    // ???????????????????????????????????????????????????????????????
    uint64_t RestExecutor::GetTimestampMs() const {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();
    }

} // namespace TradingBot::Core::Trading
