#include "RiskManager.h"
#include <iostream>
#include <cmath>

namespace TradingBot::Core::Trading {

    RiskManager::RiskManager(const RiskConfig& config)
        : config_(config)
    {
        // Инициализация: заполняем timestamps нулями
        orderTimestamps_.fill(0);
    }

    // ???????????????????????????????????????????????????????????????
    // ValidateOrder: Pre-trade проверка (HOT PATH)
    // ???????????????????????????????????????????????????????????????
    RiskCheckResult RiskManager::ValidateOrder(
        const Strategy::OrderRequest& order,
        double currentMarketPrice)
    {
        RiskCheckResult result;
        result.approved = false;

        // 1. Проверка состояния системы
        RiskState currentState = GetState();
        if (currentState == RiskState::Halted) {
            result.reason = RiskRejectReason::SystemHalted;
            result.message = "System is HALTED";
            return result;
        }

        // 2. Проверка размера ордера
        if (!CheckOrderSize(order.quantity)) {
            result.reason = RiskRejectReason::OrderSizeTooLarge;
            result.message = "Order size exceeds limit";
            return result;
        }

        // 3. Проверка лимита позиции
        if (!CheckPositionLimit(order.quantity)) {
            result.reason = RiskRejectReason::PositionLimitExceeded;
            result.message = "Position limit exceeded";
            return result;
        }

        // 4. Проверка дневных убытков
        if (!CheckDailyLoss()) {
            result.reason = RiskRejectReason::DailyLossLimitReached;
            result.message = "Daily loss limit reached";
            
            // HALT system
            Halt();
            return result;
        }

        // 5. Проверка rate limit
        if (!CheckOrderRate()) {
            result.reason = RiskRejectReason::OrderRateLimitExceeded;
            result.message = "Order rate limit exceeded";
            return result;
        }

        // 6. Проверка отклонения цены (fat finger protection)
        if (order.entryPrice > 0.0 && currentMarketPrice > 0.0) {
            if (!CheckPriceDeviation(order.entryPrice, currentMarketPrice)) {
                result.reason = RiskRejectReason::PriceDeviationTooHigh;
                result.message = "Price deviation too high (fat finger protection)";
                return result;
            }
        }

        // 7. Проверка общей экспозиции
        double additionalExposure = order.quantity * currentMarketPrice;
        if (!CheckExposureLimit(additionalExposure)) {
            result.reason = RiskRejectReason::ExposureLimitExceeded;
            result.message = "Total exposure limit exceeded";
            
            // Переходим в режим ReduceOnly
            SetState(RiskState::ReduceOnly);
            return result;
        }

        // Все проверки пройдены
        result.approved = true;
        result.reason = RiskRejectReason::None;
        result.message = "OK";

        // Записываем timestamp для rate limiting
        RecordOrderTimestamp();

        return result;
    }

    // ???????????????????????????????????????????????????????????????
    // UpdatePosition: Обновление позиции при исполнении ордера
    // ???????????????????????????????????????????????????????????????
    void RiskManager::UpdatePosition(const ExecutionReport& report) {
        if (report.state != OrderState::Filled && 
            report.state != OrderState::PartiallyFilled) {
            return;
        }

        // TODO: Различать Spot и Futures по символу
        // Пока упрощённая логика
        double executedQty = report.executedQty;
        
        // Обновляем позицию (упрощённо: всё в Spot)
        double currentPos = spotPosition_.load(std::memory_order_acquire);
        double newPos = currentPos + executedQty; // BUY добавляет, SELL вычитает
        spotPosition_.store(newPos, std::memory_order_release);

        // Обновляем PnL (упрощённая модель)
        // TODO: Реальный расчёт PnL на основе entry/exit цен
        double pnl = 0.0; // Placeholder
        currentPnL_.store(pnl, std::memory_order_release);
    }

    // ???????????????????????????????????????????????????????????????
    // ResetDailyCounters: Сброс дневных счётчиков (00:00 UTC)
    // ???????????????????????????????????????????????????????????????
    void RiskManager::ResetDailyCounters() {
        dailyPnL_.store(0.0, std::memory_order_release);
        
        // Если система была в ReduceOnly из-за лимитов, возвращаем в Normal
        if (GetState() == RiskState::ReduceOnly) {
            SetState(RiskState::Normal);
        }

        std::cout << "[RiskManager] Daily counters reset" << std::endl;
    }

    // ???????????????????????????????????????????????????????????????
    // GetOrdersThisMinute: Количество ордеров за последнюю минуту
    // ???????????????????????????????????????????????????????????????
    int RiskManager::GetOrdersThisMinute() const {
        uint64_t nowMs = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();

        uint64_t cutoffMs = nowMs - 60000; // 1 минута назад

        int count = 0;
        for (const auto& ts : orderTimestamps_) {
            if (ts >= cutoffMs) {
                ++count;
            }
        }

        return count;
    }

    // ???????????????????????????????????????????????????????????????
    // Internal Checks
    // ???????????????????????????????????????????????????????????????

    bool RiskManager::CheckPositionLimit(double orderSize) const {
        double currentPos = spotPosition_.load(std::memory_order_acquire);
        double futuresPos = futuresPosition_.load(std::memory_order_acquire);
        double totalPos = std::abs(currentPos) + std::abs(futuresPos);
        
        return (totalPos + orderSize <= config_.maxPositionBtc);
    }

    bool RiskManager::CheckOrderSize(double orderSize) const {
        return (orderSize <= config_.maxOrderSizeBtc);
    }

    bool RiskManager::CheckDailyLoss() const {
        double pnl = dailyPnL_.load(std::memory_order_acquire);
        return (pnl >= -config_.maxDailyLossUsdt);
    }

    bool RiskManager::CheckOrderRate() {
        int ordersThisMinute = GetOrdersThisMinute();
        return (ordersThisMinute < config_.maxOrdersPerMinute);
    }

    bool RiskManager::CheckPriceDeviation(double orderPrice, double marketPrice) const {
        double deviation = std::abs(orderPrice - marketPrice) / marketPrice * 100.0;
        return (deviation <= config_.maxPriceDeviationPct);
    }

    bool RiskManager::CheckExposureLimit(double additionalExposure) const {
        double currentExposure = GetCurrentExposure();
        return (currentExposure + additionalExposure <= config_.maxTotalExposureUsdt);
    }

    // ???????????????????????????????????????????????????????????????
    // RecordOrderTimestamp: Записываем timestamp для rate limiting
    // ???????????????????????????????????????????????????????????????
    void RiskManager::RecordOrderTimestamp() {
        uint64_t nowMs = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();

        size_t index = orderIndex_.fetch_add(1, std::memory_order_acq_rel) % orderTimestamps_.size();
        orderTimestamps_[index] = nowMs;
    }

} // namespace TradingBot::Core::Trading
