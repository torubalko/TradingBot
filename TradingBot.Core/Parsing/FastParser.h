#pragma once
#include <charconv>
#include <string_view>
#include <system_error>
#include "../Types.h"
#include "simdjson.h"

namespace TradingBot::Core::Parsing {

    // ???????????????????????????????????????????????????????????????
    // FastParser: Zero-Copy парсинг JSON через simdjson + from_chars
    // ???????????????????????????????????????????????????????????????
    class FastParser {
    public:
        FastParser() = default;

        // ???????????????????????????????????????????????????????????????
        // КРИТИЧНО: Zero-Copy парсинг числа без heap allocation
        // Используем std::from_chars вместо std::stod
        // ???????????????????????????????????????????????????????????????
        static inline double ParseDoubleZeroCopy(std::string_view sv) noexcept {
            double result = 0.0;
            auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), result);
            
            if (ec != std::errc()) {
                // Не бросаем исключение в hot path!
                return 0.0;
            }
            
            return result;
        }

        // ???????????????????????????????????????????????????????????????
        // Парсинг int64 (для update IDs, timestamps)
        // ???????????????????????????????????????????????????????????????
        static inline int64_t ParseInt64ZeroCopy(std::string_view sv) noexcept {
            int64_t result = 0;
            auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), result);
            
            if (ec != std::errc()) {
                return 0;
            }
            
            return result;
        }

        // ???????????????????????????????????????????????????????????????
        // Парсинг uint64 (для trade IDs)
        // ???????????????????????????????????????????????????????????????
        static inline uint64_t ParseUInt64ZeroCopy(std::string_view sv) noexcept {
            uint64_t result = 0;
            auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), result);
            
            if (ec != std::errc()) {
                return 0;
            }
            
            return result;
        }

        // ???????????????????????????????????????????????????????????????
        // Парсинг depthUpdate (diff) — HOT PATH
        // Возвращает заполненную структуру OrderBookUpdate
        // ???????????????????????????????????????????????????????????????
        static bool ParseDepthUpdate(simdjson::ondemand::document& doc, 
                                     OrderBookUpdate& update) noexcept {
            try {
                // Парсим IDs
                update.U = doc["U"].get_int64();
                update.u = doc["u"].get_int64();
                update.E = doc["E"].get_int64();
                
                // Futures имеет дополнительное поле pu
                auto puField = doc["pu"];
                if (puField.error() == simdjson::SUCCESS) {
                    update.pu = puField.get_int64();
                }

                // Очищаем старые данные (не deallocate, просто size = 0)
                update.bids.clear();
                update.asks.clear();

                // Парсим bids [["price", "quantity"], ...]
                auto bidsArray = doc["b"].get_array();
                for (auto bidElement : bidsArray) {
                    auto bidArray = bidElement.get_array();
                    auto it = bidArray.begin();

                    // ZERO-COPY: получаем string_view -> std::from_chars
                    std::string_view priceStr = (*it).get_string().value();
                    ++it;
                    std::string_view qtyStr = (*it).get_string().value();

                    OrderBookLevel level;
                    level.price = ParseDoubleZeroCopy(priceStr);
                    level.quantity = ParseDoubleZeroCopy(qtyStr);

                    update.bids.push_back(level);
                }

                // Парсим asks
                auto asksArray = doc["a"].get_array();
                for (auto askElement : asksArray) {
                    auto askArray = askElement.get_array();
                    auto it = askArray.begin();

                    std::string_view priceStr = (*it).get_string().value();
                    ++it;
                    std::string_view qtyStr = (*it).get_string().value();

                    OrderBookLevel level;
                    level.price = ParseDoubleZeroCopy(priceStr);
                    level.quantity = ParseDoubleZeroCopy(qtyStr);

                    update.asks.push_back(level);
                }

                return true;
            }
            catch (...) {
                // Не бросаем исключение в hot path
                return false;
            }
        }

        // ???????????????????????????????????????????????????????????????
        // Парсинг REST snapshot
        // ???????????????????????????????????????????????????????????????
        static bool ParseSnapshot(simdjson::ondemand::document& doc,
                                  OrderBookSnapshot& snapshot) noexcept {
            try {
                snapshot.lastUpdateId = doc["lastUpdateId"].get_int64();

                snapshot.bids.clear();
                snapshot.asks.clear();

                // Парсим bids
                auto bidsArray = doc["bids"].get_array();
                for (auto bidElement : bidsArray) {
                    auto bidArray = bidElement.get_array();
                    auto it = bidArray.begin();

                    std::string_view priceStr = (*it).get_string().value();
                    ++it;
                    std::string_view qtyStr = (*it).get_string().value();

                    OrderBookLevel level;
                    level.price = ParseDoubleZeroCopy(priceStr);
                    level.quantity = ParseDoubleZeroCopy(qtyStr);

                    snapshot.bids.push_back(level);
                }

                // Парсим asks
                auto asksArray = doc["asks"].get_array();
                for (auto askElement : asksArray) {
                    auto askArray = askElement.get_array();
                    auto it = askArray.begin();

                    std::string_view priceStr = (*it).get_string().value();
                    ++it;
                    std::string_view qtyStr = (*it).get_string().value();

                    OrderBookLevel level;
                    level.price = ParseDoubleZeroCopy(priceStr);
                    level.quantity = ParseDoubleZeroCopy(qtyStr);

                    snapshot.asks.push_back(level);
                }

                return true;
            }
            catch (...) {
                return false;
            }
        }

        // ???????????????????????????????????????????????????????????????
        // Парсинг aggTrade
        // ???????????????????????????????????????????????????????????????
        static bool ParseAggTrade(simdjson::ondemand::document& doc,
                                  AggTrade& trade) noexcept {
            try {
                // Parse fields
                trade.tradeId = doc["a"].get_uint64();
                
                std::string_view priceStr = doc["p"].get_string().value();
                std::string_view qtyStr = doc["q"].get_string().value();
                
                trade.price = ParseDoubleZeroCopy(priceStr);
                trade.quantity = ParseDoubleZeroCopy(qtyStr);
                trade.isBuyerMaker = doc["m"].get_bool();
                trade.timestampMs = doc["T"].get_uint64();

                return true;
            }
            catch (...) {
                return false;
            }
        }

        // ???????????????????????????????????????????????????????????????
        // Получение типа события из JSON (быстрая проверка)
        // ???????????????????????????????????????????????????????????????
        static std::string_view GetEventType(simdjson::ondemand::document& doc) noexcept {
            try {
                auto eField = doc["e"];
                if (eField.error() == simdjson::SUCCESS) {
                    return eField.get_string().value();
                }
            }
            catch (...) {
            }
            return "";
        }

        // ???????????????????????????????????????????????????????????????
        // Проверка Combined Stream wrapper
        // ???????????????????????????????????????????????????????????????
        static bool IsCombinedStream(simdjson::ondemand::document& doc) noexcept {
            try {
                auto streamField = doc["stream"];
                return streamField.error() == simdjson::SUCCESS;
            }
            catch (...) {
                return false;
            }
        }
    };

} // namespace TradingBot::Core::Parsing
