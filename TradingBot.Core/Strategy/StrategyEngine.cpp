#include "StrategyEngine.h"
#include <iostream>
#include <cmath>

namespace TradingBot::Core::Strategy {

    StrategyEngine::StrategyEngine() {
        // Конструктор: дефолтная конфигурация
    }

    // ???????????????????????????????????????????????????????????????
    // OnTick: Главный метод стратегии (вызывается каждый тик)
    // ???????????????????????????????????????????????????????????????
    void StrategyEngine::OnTick(const OrderBook::LocalOrderBook& spotBook,
                                const OrderBook::LocalOrderBook& futuresBook) {
        // Сброс сигнала
        currentSignal_ = StrategySignal::None;

        // 1. Сканируем стакан на плотности
        densityDetector_.Scan(spotBook);
        auto densities = densityDetector_.GetDensities();

        if (densities.empty()) {
            return; // Нет значимых плотностей
        }

        // 2. Получаем сигнал от TakerFlowAnalyzer
        TakerFlowSignal takerSignal = takerAnalyzer_.GetSignal(densities);

        // 3. Ищем точки входа
        bool longFound = FindLongEntry(spotBook, densities, takerSignal);
        if (longFound) {
            return; // Нашли лонг, не ищем шорт
        }

        bool shortFound = FindShortEntry(spotBook, densities, takerSignal);
        if (shortFound) {
            return;
        }

        // TODO: Логика выхода из позиции (exitLong, exitShort)
    }

    // ???????????????????????????????????????????????????????????????
    // OnAggTrade: Обработка входящих сделок
    // ???????????????????????????????????????????????????????????????
    void StrategyEngine::OnAggTrade(const AggTrade& trade) {
        takerAnalyzer_.ProcessTrade(trade);
    }

    // ???????????????????????????????????????????????????????????????
    // FindLongEntry: Поиск точки входа в лонг (отскок от bid wall)
    // ???????????????????????????????????????????????????????????????
    bool StrategyEngine::FindLongEntry(
        const OrderBook::LocalOrderBook& book,
        const std::span<const DensityLevel>& densities,
        const TakerFlowSignal& signal)
    {
        double currentPrice = book.GetMidPrice();
        if (currentPrice <= 0.0) {
            return false;
        }

        // Ищем ближайшую bid wall (поддержку)
        for (const auto& density : densities) {
            if (density.side != Side::BID) {
                continue; // Пропускаем ask walls
            }

            // Проверяем расстояние до стены
            double distance = (currentPrice - density.price) / currentPrice * 100.0;
            
            if (distance < config_.minDistanceToWall || 
                distance > config_.maxDistanceToWall) {
                continue; // Слишком близко или слишком далеко
            }

            // Проверяем условия входа
            if (!CheckEntryConditions(density, currentPrice, signal, true)) {
                continue;
            }

            // Нашли точку входа в лонг
            double entryPrice = currentPrice;
            double stopLoss = density.price * (1.0 - config_.stopLossPercent / 100.0);
            double takeProfit = entryPrice * (1.0 + config_.takeProfitPercent / 100.0);

            GenerateOrderRequest(StrategySignal::LongEntry, entryPrice, stopLoss, takeProfit);
            
            std::cout << "[StrategyEngine] LONG ENTRY signal at " << entryPrice
                      << " (wall at " << density.price << ")" << std::endl;

            return true;
        }

        return false;
    }

    // ???????????????????????????????????????????????????????????????
    // FindShortEntry: Поиск точки входа в шорт (отскок от ask wall)
    // ???????????????????????????????????????????????????????????????
    bool StrategyEngine::FindShortEntry(
        const OrderBook::LocalOrderBook& book,
        const std::span<const DensityLevel>& densities,
        const TakerFlowSignal& signal)
    {
        double currentPrice = book.GetMidPrice();
        if (currentPrice <= 0.0) {
            return false;
        }

        // Ищем ближайшую ask wall (сопротивление)
        for (const auto& density : densities) {
            if (density.side != Side::ASK) {
                continue;
            }

            // Проверяем расстояние до стены
            double distance = (density.price - currentPrice) / currentPrice * 100.0;
            
            if (distance < config_.minDistanceToWall || 
                distance > config_.maxDistanceToWall) {
                continue;
            }

            // Проверяем условия входа
            if (!CheckEntryConditions(density, currentPrice, signal, false)) {
                continue;
            }

            // Нашли точку входа в шорт
            double entryPrice = currentPrice;
            double stopLoss = density.price * (1.0 + config_.stopLossPercent / 100.0);
            double takeProfit = entryPrice * (1.0 - config_.takeProfitPercent / 100.0);

            GenerateOrderRequest(StrategySignal::ShortEntry, entryPrice, stopLoss, takeProfit);
            
            std::cout << "[StrategyEngine] SHORT ENTRY signal at " << entryPrice
                      << " (wall at " << density.price << ")" << std::endl;

            return true;
        }

        return false;
    }

    // ???????????????????????????????????????????????????????????????
    // CheckEntryConditions: Проверка условий входа
    // ???????????????????????????????????????????????????????????????
    bool StrategyEngine::CheckEntryConditions(
        const DensityLevel& wall,
        double currentPrice,
        const TakerFlowSignal& signal,
        bool isLong) const
    {
        // 1. Проверяем, не под атакой ли стена
        if (config_.filterWallUnderAttack && signal.densityUnderAttack) {
            if (std::abs(signal.attackedPrice - wall.price) < wall.price * 0.001) {
                return false; // Стена под атакой, не входим
            }
        }

        // 2. Проверяем imbalance (дисбаланс объёма)
        if (isLong) {
            // Для лонга нужен buy pressure (покупатели сильнее)
            if (signal.buyPressure < config_.minImbalanceForEntry) {
                return false;
            }
        } else {
            // Для шорта нужен sell pressure
            if (signal.sellPressure < config_.minImbalanceForEntry) {
                return false;
            }
        }

        // 3. Проверяем, что нет крупных агрессоров в противоположном направлении
        if (isLong && signal.largeSellerDetected) {
            return false; // Крупный продавец, не входим в лонг
        }

        if (!isLong && signal.largeBuyerDetected) {
            return false; // Крупный покупатель, не входим в шорт
        }

        return true;
    }

    // ???????????????????????????????????????????????????????????????
    // GenerateOrderRequest: Генерация запроса на ордер
    // ???????????????????????????????????????????????????????????????
    void StrategyEngine::GenerateOrderRequest(
        StrategySignal signal,
        double entryPrice,
        double stopLoss,
        double takeProfit)
    {
        currentSignal_ = signal;

        pendingOrder_.signal = signal;
        pendingOrder_.entryPrice = entryPrice;
        pendingOrder_.quantity = config_.defaultQuantity;
        pendingOrder_.stopLoss = stopLoss;
        pendingOrder_.takeProfit = takeProfit;
    }

} // namespace TradingBot::Core::Strategy
