#include "TakerFlowAnalyzer.h"
#include <algorithm>
#include <cmath>

namespace TradingBot::Core::Strategy {

    TakerFlowAnalyzer::TakerFlowAnalyzer() {
        // Конструктор
    }

    // ???????????????????????????????????????????????????????????????
    // ProcessTrade: Обработка каждого aggTrade (HOT PATH)
    // ???????????????????????????????????????????????????????????????
    void TakerFlowAnalyzer::ProcessTrade(const AggTrade& trade) {
        // Очищаем устаревшие сделки
        CleanOldTrades();

        // Добавляем новую сделку в ring buffer
        tradeBuffer_[tradeHead_] = trade;
        tradeHead_ = (tradeHead_ + 1) % tradeBuffer_.size();

        if (tradeCount_ < tradeBuffer_.size()) {
            ++tradeCount_;
        } else {
            // Буфер полон, сдвигаем tail
            tradeTail_ = (tradeTail_ + 1) % tradeBuffer_.size();
        }

        // Проверяем крупные сделки
        if (trade.quantity >= largeTradeThreshold_) {
            if (trade.isBuyerMaker) {
                // Продавец агрессор (крупная продажа)
                lastLargeSellerDetected_ = true;
            } else {
                // Покупатель агрессор (крупная покупка)
                lastLargeBuyDetected_ = true;
            }
        }
    }

    // ???????????????????????????????????????????????????????????????
    // GetMetrics: Получение текущих метрик
    // ???????????????????????????????????????????????????????????????
    TakerFlowMetrics TakerFlowAnalyzer::GetMetrics() const {
        return CalculateMetrics();
    }

    // ???????????????????????????????????????????????????????????????
    // GetSignal: Формирование сигнала для стратегии
    // ???????????????????????????????????????????????????????????????
    TakerFlowSignal TakerFlowAnalyzer::GetSignal(
        const std::span<const DensityLevel>& densities) 
    {
        TakerFlowSignal signal;

        // Получаем метрики
        TakerFlowMetrics metrics = GetMetrics();

        // Вычисляем Buy/Sell Pressure (0.0 - 1.0)
        double totalVolume = metrics.buyVolume + metrics.sellVolume;
        if (totalVolume > 0.0) {
            signal.buyPressure = metrics.buyVolume / totalVolume;
            signal.sellPressure = metrics.sellVolume / totalVolume;
        }

        // Крупные покупатели/продавцы
        signal.largeBuyerDetected = lastLargeBuyDetected_;
        signal.largeSellerDetected = lastLargeSellerDetected_;

        // Проверяем атаку на уровни плотности
        uint64_t currentTimeMs = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();

        for (const auto& density : densities) {
            if (IsLevelUnderAttack(density, currentTimeMs)) {
                signal.densityUnderAttack = true;
                signal.attackedPrice = density.price;
                break;
            }
        }

        return signal;
    }

    // ???????????????????????????????????????????????????????????????
    // CleanOldTrades: Удаление устаревших сделок из ring buffer
    // ???????????????????????????????????????????????????????????????
    void TakerFlowAnalyzer::CleanOldTrades() {
        if (tradeCount_ == 0) {
            return;
        }

        uint64_t currentTimeMs = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();

        uint64_t cutoffTimeMs = currentTimeMs - windowSizeMs_;

        // Удаляем сделки старше cutoff
        while (tradeCount_ > 0) {
            const AggTrade& oldestTrade = tradeBuffer_[tradeTail_];
            
            if (oldestTrade.timestampMs >= cutoffTimeMs) {
                break; // Сделка ещё актуальна
            }

            // Удаляем старую сделку
            tradeTail_ = (tradeTail_ + 1) % tradeBuffer_.size();
            --tradeCount_;
        }
    }

    // ???????????????????????????????????????????????????????????????
    // CalculateMetrics: Вычисление метрик на основе буфера
    // ???????????????????????????????????????????????????????????????
    TakerFlowMetrics TakerFlowAnalyzer::CalculateMetrics() const {
        TakerFlowMetrics metrics;

        if (tradeCount_ == 0) {
            return metrics;
        }

        // Итерация по ring buffer
        size_t index = tradeTail_;
        for (size_t i = 0; i < tradeCount_; ++i) {
            const AggTrade& trade = tradeBuffer_[index];

            if (trade.isBuyerMaker) {
                // Продавец агрессор
                metrics.sellVolume += trade.quantity;
                metrics.sellVolumeQuote += trade.price * trade.quantity;
                ++metrics.sellCount;
            } else {
                // Покупатель агрессор
                metrics.buyVolume += trade.quantity;
                metrics.buyVolumeQuote += trade.price * trade.quantity;
                ++metrics.buyCount;
            }

            index = (index + 1) % tradeBuffer_.size();
        }

        // Вычисляем imbalance ratio
        double totalVolume = metrics.buyVolume + metrics.sellVolume;
        if (totalVolume > 0.0) {
            metrics.imbalanceRatio = (metrics.buyVolume - metrics.sellVolume) / totalVolume;
        }

        return metrics;
    }

    // ???????????????????????????????????????????????????????????????
    // IsLevelUnderAttack: Проверка атаки на уровень плотности
    // ???????????????????????????????????????????????????????????????
    bool TakerFlowAnalyzer::IsLevelUnderAttack(
        const DensityLevel& level, 
        uint64_t currentTimeMs) const 
    {
        // Проверяем, есть ли крупные сделки рядом с уровнем
        const double PRICE_TOLERANCE = 0.001; // 0.1% от цены
        double priceRange = level.price * PRICE_TOLERANCE;

        uint64_t cutoffTimeMs = currentTimeMs - windowSizeMs_;
        double volumeNearLevel = 0.0;
        int tradesNearLevel = 0;

        size_t index = tradeTail_;
        for (size_t i = 0; i < tradeCount_; ++i) {
            const AggTrade& trade = tradeBuffer_[index];

            if (trade.timestampMs < cutoffTimeMs) {
                index = (index + 1) % tradeBuffer_.size();
                continue;
            }

            // Проверяем, близка ли сделка к уровню
            if (std::abs(trade.price - level.price) <= priceRange) {
                volumeNearLevel += trade.quantity;
                ++tradesNearLevel;
            }

            index = (index + 1) % tradeBuffer_.size();
        }

        // Считаем уровень под атакой, если:
        // 1. Есть минимум 3 сделки рядом с уровнем
        // 2. Суммарный объём > 10% от объёма плотности
        return (tradesNearLevel >= 3 && volumeNearLevel > level.volume * 0.1);
    }

} // namespace TradingBot::Core::Strategy
