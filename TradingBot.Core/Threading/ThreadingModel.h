#pragma once

// ???????????????????????????????????????????????????????????????
// Threading Model: Многопоточная архитектура TradingBot
// ???????????????????????????????????????????????????????????????
//
// ?????????????????????????????????????????????????????????????
// ?                    STARTUP PHASE                          ?
// ?  • ObjectPools pre-allocated                              ?
// ?  • Vectors .reserve() called                              ?
// ?  • SPSC queues created                                    ?
// ?  • Threads spawned                                        ?
// ?????????????????????????????????????????????????????????????
//                           ?
// ???????????????????????????????????????????????????????
// ?        ?        ?        ?        ?        ?        
// ???????? ???????? ???????? ???????? ???????? ????????
// ? SPOT ? ?FUTURE? ? USER ? ? MAIN ? ?LOGGER? ? TCP  ?
// ?THREAD? ?THREAD? ? DATA ? ?THREAD? ?THREAD? ?SERVER?
// ?      ? ?      ? ?THREAD? ?      ? ?      ? ?THREAD?
// ?      ? ?      ? ?      ? ?      ? ?      ? ?      ?
// ?io_ctx? ?io_ctx? ?io_ctx? ?while ? ?while ? ?accept?
// ?.run()? ?.run()? ?.run()? ?poll()? ?flush? ?send()?
// ?      ? ?      ? ?      ? ?parse ? ?write ? ?      ?
// ?depth ? ?depth ? ?execRpt? ?updte? ?      ? ?      ?
// ?trade ? ?trade ? ?      ? ?strat ? ?      ? ?      ?
// ?      ? ?      ? ?      ? ?risk  ? ?      ? ?      ?
// ?      ? ?      ? ?      ? ?oms   ? ?      ? ?      ?
// ???????? ???????? ???????? ???????? ???????? ????????
//    ?        ?        ?        ?        ?
//    ?  SPSC  ?  SPSC  ?  SPSC  ?  SPSC  ?
//    ?????????????????????????????????????
//         (lock-free queues between threads)
//
// ???????????????????????????????????????????????????????????????
// THREAD ROLES:
// ???????????????????????????????????????????????????????????????
//
// 1. SPOT WebSocket Thread
//    - boost::asio::io_context.run()
//    - Receive depth@100ms, aggTrade
//    - Parse с simdjson (zero-copy)
//    - Push updates в SPSC queue ? MAIN THREAD
//    - HOT PATH: no locks, no allocations
//
// 2. FUTURES WebSocket Thread
//    - То же самое, но для futures market
//    - Независимая io_context
//    - Отдельная SPSC queue ? MAIN THREAD
//
// 3. USER DATA WebSocket Thread
//    - Receive executionReport, outboundAccountPosition
//    - Push в SPSC queue ? MAIN THREAD
//    - Используется для tracking своих ордеров
//
// 4. MAIN THREAD (Strategy + Risk + OMS)
//    - Poll всех SPSC queues (spot, futures, userData)
//    - Apply updates to LocalOrderBook
//    - Run StrategyEngine (TakerFlowAnalyzer + DensityDetector)
//    - Run RiskManager (pre-trade checks)
//    - Submit orders через RestExecutor
//    - HOT PATH: минимальные аллокации
//
// 5. LOGGER THREAD
//    - Consume от AsyncLogger ring buffer
//    - Batch write в файл
//    - File rotation
//    - НЕ в hot path
//
// 6. TCP SERVER THREAD
//    - Accept connections от UI
//    - Send telemetry / orderBook / trades
//    - Receive commands (pause/resume/setRiskParam)
//    - НЕ в hot path
//
// ???????????????????????????????????????????????????????????????
// DATA FLOW (lock-free):
// ???????????????????????????????????????????????????????????????
//
// SPOT THREAD:
//   WebSocket ? Parse ? ObjectPool.Acquire() ? SPSC.push()
//
// MAIN THREAD:
//   SPSC.pop() ? OrderBook.ApplyUpdate() ? Strategy.OnUpdate()
//              ? RiskManager.ValidateOrder() ? OMS.SubmitOrder()
//              ? ObjectPool.Release()
//
// LOGGER THREAD:
//   RingBuffer.pop() ? File.write() ? RingBuffer.advance()
//
// TCP SERVER THREAD:
//   OrderBook.GetSnapshot() ? Serialize ? TCP.send()
//
// ???????????????????????????????????????????????????????????????
// SYNCHRONIZATION:
// ???????????????????????????????????????????????????????????????
//
// ? NO MUTEXES в hot path
// ? SPSC queues (boost::lockfree::spsc_queue)
// ? Atomic counters для statistics
// ? Memory barriers (std::memory_order)
//
// EXCEPTION:
// - SharedState (RW lock для snapshot requests от UI)
//   НО: ReadLock используется только в UI thread (не hot path)
//
// ???????????????????????????????????????????????????????????????
// LATENCY BREAKDOWN (target):
// ???????????????????????????????????????????????????????????????
//
// WebSocket receive:           ~100 µs (network)
// Parse (simdjson):            ~50 µs
// SPSC queue push:             ~20 ns
// SPSC queue pop:              ~20 ns
// OrderBook update:            ~500 ns
// Strategy evaluation:         ~1 µs
// Risk check:                  ~100 ns
// Order submit (REST):         ~5 ms (network)
// ???????????????????????????????????????????
// Total (hot path):            ~150 µs (excluding network)
// End-to-end (with REST):      ~5-10 ms
//
// ???????????????????????????????????????????????????????????????
// MEMORY MODEL:
// ???????????????????????????????????????????????????????????????
//
// PRE-ALLOCATED at startup:
// - ObjectPool<OrderBookUpdate, 512>     ? 512 KB
// - ObjectPool<OrderRequest, 256>        ? 256 KB
// - SPSCQueue<OrderBookUpdate*, 1024>    ? 8 KB
// - AsyncLogger ring buffer (16K)        ? 4 MB
// - LocalOrderBook bids/asks (1000 lvl)  ? 32 KB
// ???????????????????????????????????????????????
// Total:                                  ~5 MB
//
// RUNTIME (hot path):
// - Allocations:     0
// - Deallocations:   0
// - Locks:           0
// - Exceptions:      0
//
// ???????????????????????????????????????????????????????????????
// ERROR HANDLING:
// ???????????????????????????????????????????????????????????????
//
// NETWORK ERRORS (WebSocket disconnect):
// - Exponential backoff reconnect
// - Buffer diffs during reconnection
// - Re-sync snapshot after reconnect
//
// POOL EXHAUSTION:
// - Log error (AsyncLogger)
// - Drop update (strategy will miss 1 tick, acceptable)
// - Increase pool size in config
//
// QUEUE OVERFLOW:
// - Log warning
// - Drop update
// - Increase queue capacity
//
// FATAL ERRORS:
// - Log fatal + flush
// - Graceful shutdown (cancel all orders)
// - Exit with error code
//
// ???????????????????????????????????????????????????????????????

namespace TradingBot::Core::Threading {

    // Thread IDs для pin-to-core (опционально)
    enum class ThreadId {
        SpotWebSocket = 0,
        FuturesWebSocket = 1,
        UserDataStream = 2,
        MainStrategy = 3,
        Logger = 4,
        TcpServer = 5
    };

    // Thread priorities (platform-specific)
    enum class ThreadPriority {
        RealTime,   // SpotWebSocket, FuturesWebSocket (HOT PATH)
        High,       // MainStrategy
        Normal,     // UserDataStream
        Low         // Logger, TcpServer
    };

} // namespace TradingBot::Core::Threading
