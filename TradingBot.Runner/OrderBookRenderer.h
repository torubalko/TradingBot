#pragma once
#include <memory>
#include <vector>
#include <deque>
#include "Graphics.h"
#include "../TradingBot.Core/SharedState.h"

// ???????????????????????????????????????????????????????????????
// OrderBookRenderer: GPU-accelerated визуализация Order Book
// 
// ОПТИМИЗАЦИИ:
// - Lock-free чтение из SharedState (не блокирует бот)
// - Batch rendering (один draw call для всех баров)
// - Pre-allocated буферы (zero allocations в render loop)
// - GPU instancing (минимальная нагрузка на CPU)
// ???????????????????????????????????????????????????????????????

class OrderBookRenderer {
public:
    enum class VolumeMode { Base = 0, Quote = 1 };

    OrderBookRenderer(Graphics* graphics, std::shared_ptr<TradingBot::Core::SharedState> sharedState);
    ~OrderBookRenderer();

    // Рендеринг Order Book (вызывается каждый кадр)
    void Render(float x, float y, float width, float height);

    // Настройки визуализации
    void SetDepth(int levels) { visibleLevels_ = levels; }
    void SetMaxBarWidth(float width) { maxBarWidth_ = width; }
    void SetVolumeMode(VolumeMode mode) { volumeMode_ = mode; }
    void SetCompressionFactor(double factor) {
        int step = static_cast<int>(factor);
        if (step < 1) step = 1;
        if (step > 1000) step = 1000;
        compressionStep_ = step;
    }

private:
    // ???????????????????????????????????????????????????????????
    // Internal Rendering Methods
    // ???????????????????????????????????????????????????????????
    
    void RenderBids(float x, float y, float width, float height, 
                    const std::vector<std::pair<double, double>>& bids,
                    double maxVolume,
                    double midPrice);
    
    void RenderAsks(float x, float y, float width, float height,
                    const std::vector<std::pair<double, double>>& asks,
                    double maxVolume,
                    double midPrice);
    
    void RenderSpreadLine(float x, float y, float width, double bidPrice, double askPrice);
    
    // Расчёт максимального объёма для нормализации баров
    double CalculateMaxVolume(const std::vector<std::pair<double, double>>& bids,
                             const std::vector<std::pair<double, double>>& asks);

    // ???????????????????????????????????????????????????????????
    // Members
    // ???????????????????????????????????????????????????????????
    
    Graphics* graphics_;
    std::shared_ptr<TradingBot::Core::SharedState> sharedState_;
    VolumeMode volumeMode_ = VolumeMode::Base;
    
    // Настройки
    int visibleLevels_ = 20;        // Сколько уровней показывать
    float maxBarWidth_ = 300.0f;    // Максимальная ширина бара
    float levelHeight_ = 20.0f;     // Высота одного уровня
    int   compressionStep_ = 1;      // Шаг выборки уровней
    
    // Pre-allocated буферы (для zero-allocation в render loop)
    std::vector<std::pair<double, double>> cachedBids_;
    std::vector<std::pair<double, double>> cachedAsks_;

    // Mini chart history for mid-price
    std::deque<double> midHistory_;
    double lastMid_ = 0.0;
};